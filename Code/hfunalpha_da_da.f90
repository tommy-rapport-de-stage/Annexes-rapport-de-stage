!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunalpha_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hd
!   with respect to varying inputs: alpha
!   RW status of diff variables: alpha:in hd:out
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunalpha in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h
!   with respect to varying inputs: pdeltai m alpha deltai
!   RW status of diff variables: h:out pdeltai:in m:in alpha:in
!                deltai:in
!#######################################################################
!## Hamiltonian
SUBROUTINE HFUNALPHA_DA_DA(m, md, deltai, deltaid, pdeltai, pdeltaid, &
& alpha, alphad0, alphad, pars, cont, h, hd, hdd)
  IMPLICIT NONE
!!!!!!!!!
!h = u(1)
!!!!!!!!!
  DOUBLE PRECISION, INTENT(IN) :: m, alpha, deltai(5), pdeltai(5), pars(&
& 11), cont
  DOUBLE PRECISION, INTENT(IN) :: alphad0
  DOUBLE PRECISION, INTENT(IN) :: md, alphad, deltaid(5), pdeltaid(5)
  DOUBLE PRECISION, INTENT(OUT) :: h
  DOUBLE PRECISION, INTENT(OUT) :: hd
  DOUBLE PRECISION, INTENT(OUT) :: hdd
!local variables
  DOUBLE PRECISION :: mu, i(5), bsail(3), sdir(3)
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3)
  DOUBLE PRECISION :: pigd0(3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3)
  DOUBLE PRECISION :: pigdd(3)
  DOUBLE PRECISION :: usail(3), u(3), nnorb, hsail, aaorb
  DOUBLE PRECISION :: usaild0(3)
  DOUBLE PRECISION :: usaild(3), hsaild
  DOUBLE PRECISION :: usaildd(3), hsaildd
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
! Gravitational constant
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Optical coefficients
  bsail = pars(9:11)
! Direction of the Sun
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
! GVEs
  CALL GVEECI_DA(m, md, i, mu, fx, fxd, fy, fyd, fz, fzd)
  CALL DOT_DA(5, pdeltai, pdeltaid, fx, fxd, pig(1), pigd(1))
  CALL DOT_DA(5, pdeltai, pdeltaid, fy, fyd, pig(2), pigd(2))
  CALL DOT_DA(5, pdeltai, pdeltaid, fz, fzd, pig(3), pigd(3))
! Hamiltonian of the sail
  CALL PMPSAIL_DA_DA(pig, pigd, sdir, alpha, alphad0, alphad, bsail, &
&              usail, usaild0, usaild, usaildd)
  CALL DOT_DA_DA(3, pig, pigd, usail, usaild0, usaild, usaildd, hsail, &
&          hsaild, hsaildd)
  hdd = hsaildd
  hd = hsaild
  h = hsail
! Mean longitude as time variable
  aaorb = pars(5)
  arg1 = mu/aaorb**3
  nnorb = SQRT(arg1)
  hdd = hdd/nnorb
  hd = hd/nnorb
  h = h/nnorb
END SUBROUTINE HFUNALPHA_DA_DA

!  Differentiation of pmpsail_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud
!   with respect to varying inputs: alpha
!  Differentiation of pmpsail in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: alpha pig
!#######################################################################
!# PMP of the sail
SUBROUTINE PMPSAIL_DA_DA(pig, pigd, sdir, alpha, alphad0, alphad, b, u, &
& ud0, ud, udd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), alpha, sdir(3), b(3)
  DOUBLE PRECISION, INTENT(IN) :: alphad0
  DOUBLE PRECISION, INTENT(IN) :: pigd(3), alphad
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd(3)
! local variables
  DOUBLE PRECISION :: b1, b2, b3, pis, pinorm, theta, kpolar, sperp(3), &
& calpha, salpha, fs, fperp
  DOUBLE PRECISION :: calphad0, salphad0, fsd0, fperpd0
  DOUBLE PRECISION :: pisd, sperpd(3), calphad, salphad, fsd, fperpd
  DOUBLE PRECISION :: calphadd, salphadd, fsdd, fperpdd
  INTRINSIC SQRT
  INTRINSIC ACOS
  INTRINSIC COS
  INTRINSIC SIN
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result10
  b1 = b(1)
  b2 = b(2)
  b3 = b(3)
  pisd = sdir(1)*pigd(1) + sdir(2)*pigd(2) + sdir(3)*pigd(3)
  pis = pig(1)*sdir(1) + pig(2)*sdir(2) + pig(3)*sdir(3)
  arg1 = pig(1)**2 + pig(2)**2 + pig(3)**2
  pinorm = SQRT(arg1)
  theta = ACOS(pis/pinorm)
! Definition of the unit vector sPerp
  sperpd = pigd - sdir*pisd
  sperp = pig - pis*sdir
! Note: nan for collinear vectors
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
  ELSE
    result10 = SQRT(arg1)
    result1d = arg1d/(2.0*result10)
  END IF
  result1 = SQRT(arg1)
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperp = sperp/result1
  calphadd = -(alphad*alphad0*COS(alpha))
  calphad = -(alphad*SIN(alpha))
  calphad0 = -(alphad0*SIN(alpha))
  calpha = COS(alpha)
  salphadd = -(alphad*alphad0*SIN(alpha))
  salphad = alphad*COS(alpha)
  salphad0 = alphad0*COS(alpha)
  salpha = SIN(alpha)
! Optimal force
  fsdd = b1*calphadd + (b2*2*(calphad0*calphad+calpha*calphadd)+b3*&
&   calphadd)*calpha + (b2*2*calpha*calphad+b3*calphad)*calphad0 + (b2*2&
&   *calpha*calphad0+b3*calphad0)*calphad + (b2*calpha**2+b3*calpha)*&
&   calphadd
  fsd = b1*calphad + (b2*2*calpha*calphad+b3*calphad)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad
  fsd0 = b1*calphad0 + (b2*2*calpha*calphad0+b3*calphad0)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad0
  fs = b1*calpha + (b2*calpha**2+b3*calpha)*calpha
  fperpdd = (b2*2*(calphad0*calphad+calpha*calphadd)+b3*calphadd)*salpha&
&   + (b2*2*calpha*calphad+b3*calphad)*salphad0 + (b2*2*calpha*calphad0+&
&   b3*calphad0)*salphad + (b2*calpha**2+b3*calpha)*salphadd
  fperpd = (b2*2*calpha*calphad+b3*calphad)*salpha + (b2*calpha**2+b3*&
&   calpha)*salphad
  fperpd0 = (b2*2*calpha*calphad0+b3*calphad0)*salpha + (b2*calpha**2+b3&
&   *calpha)*salphad0
  fperp = (b2*calpha**2+b3*calpha)*salpha
  udd = sdir*fsdd + sperp*fperpdd + sperpd*fperpd0
  ud = sdir*fsd + fperpd*sperp + fperp*sperpd
  ud0 = sdir*fsd0 + sperp*fperpd0
  u = fs*sdir + fperp*sperp
END SUBROUTINE PMPSAIL_DA_DA

!  Differentiation of dot_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd
!   with respect to varying inputs: v vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DA_DA(n, u, ud, v, vd0, vd, vdd, res, resd, resdd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: vdd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.D0
  DO i=1,n
    resdd = resdd + ud(i)*vd0(i) + u(i)*vdd(i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DA_DA

