!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunimplicit in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h
!   with respect to varying inputs: cont m p q
!   RW status of diff variables: h:out cont:in m:in p:in q:in
SUBROUTINE HFUNIMPLICIT_DI(m, md, q, qd, p, pd, pars, cont, contd, h, hd&
&)
  IMPLICIT NONE
!else
!   h       = 0.0D0
!end if
!implicit none
  DOUBLE PRECISION, INTENT(IN) :: m, q(6), p(6), pars(11), cont
  DOUBLE PRECISION, INTENT(IN) :: md, qd(6), pd(6), contd
  DOUBLE PRECISION, INTENT(OUT) :: h
  DOUBLE PRECISION, INTENT(OUT) :: hd
!local variables
  DOUBLE PRECISION :: hhat, g, nnorb, mu, palpha, alpha, deltai(5), &
& pdeltai(5), dum, h_u, h_p, h_cp, h_ci
  DOUBLE PRECISION :: hhatd, gd, palphad, alphad, pdeltaid(5), dumd, &
& h_ud, h_pd, h_cpd
  DOUBLE PRECISION :: h_i, h_m, h_uu, h_pu, h_iu, h_mu, ddeltai(5), &
& dpdeltai(5)
  DOUBLE PRECISION :: h_id, h_md, h_uud, h_pud, h_iud, h_mud, dpdeltaid(&
& 5)
  DOUBLE PRECISION :: i(5), bsail(3), sdir(3)
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3)
  DOUBLE PRECISION :: hsail
  DOUBLE PRECISION :: fcone(2), ucone(3), hcone
  DOUBLE PRECISION :: uconed(3), hconed
  INTEGER :: idx
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Forces on convex cone
  fcone = pars(7:8)
! Optical coefficients
  bsail = pars(9:11)
  deltai = q(1:5)
  alphad = qd(6)
  alpha = q(6)
  pdeltaid = pd(1:5)
  pdeltai = p(1:5)
  palphad = pd(6)
  palpha = p(6)
! Direction of the Sun
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
! GVEs
  CALL GVEECI_DI(m, md, i, mu, fx, fxd, fy, fyd, fz, fzd)
  CALL DOT_DI(5, pdeltai, pdeltaid, fx, fxd, pig(1), pigd(1))
  CALL DOT_DI(5, pdeltai, pdeltaid, fy, fyd, pig(2), pigd(2))
  CALL DOT_DI(5, pdeltai, pdeltaid, fz, fzd, pig(3), pigd(3))
! Hamiltonian of the cone
  CALL PMPCONE_DI(pig, pigd, sdir, fcone, ucone, uconed)
  CALL DOT_DI(3, pig, pigd, ucone, uconed, hcone, hconed)
!-------------------------------------------------
  ddeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
  dpdeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
!call hfunalpha_d(M, deltaI, ddeltaI, pdeltaI, dpdeltaI, alpha, 1.0D0, dum, h_u)
  CALL HFUNALPHA_DA_DA_DI(m, md, 0.0d0, deltai, ddeltai, pdeltai, &
&                   pdeltaid, dpdeltai, alpha, alphad, 1.0d0, 1.0d0, &
&                   pars, cont, hhat, hhatd, h_u, h_ud, h_uu, h_uud)
!call hfunalpha_da(M, 1.0D0, deltaI, ddeltaI, pdeltaI, dpdeltaI, alpha, 0.0D0, pars, cont, dum, h_m)
  CALL HFUNALPHA_DA_DA_DI(m, md, 1.0d0, deltai, ddeltai, pdeltai, &
&                   pdeltaid, dpdeltai, alpha, alphad, 1.0d0, 0.0d0, &
&                   pars, cont, dum, dumd, h_m, h_md, h_mu, h_mud)
  gd = h_mud
  g = h_mu
  DO idx=1,5
    ddeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    dpdeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    ddeltai(idx) = 1.0d0
    CALL HFUNALPHA_DA_DA_DI(m, md, 0.0d0, deltai, ddeltai, pdeltai, &
&                     pdeltaid, dpdeltai, alpha, alphad, 1.0d0, 0.0d0, &
&                     pars, cont, dum, dumd, h_i, h_id, h_iu, h_iud)
    ddeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    dpdeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    dpdeltaid(idx) = 0.D0
    dpdeltai(idx) = 1.0d0
    CALL HFUNALPHA_DA_DA_DI(m, md, 0.0d0, deltai, ddeltai, pdeltai, &
&                     pdeltaid, dpdeltai, alpha, alphad, 1.0d0, 0.0d0, &
&                     pars, cont, dum, dumd, h_p, h_pd, h_pu, h_pud)
    CALL HFUNCONE_DC_DI(m, md, 0.0, pdeltai, pdeltaid, dpdeltai, pars, &
&                 dum, h_cp, h_cpd)
    gd = gd + h_iud*(h_cp*(1.0d0-cont)+h_p*cont) + h_iu*(h_cpd*(1.0d0-&
&     cont)-h_cp*contd+h_pd*cont+h_p*contd) - h_pud*h_i - h_pu*h_id
    g = g + (h_iu*(h_cp*(1.0d0-cont)+h_p*cont)-h_pu*h_i)
  END DO
  gd = -((gd*h_uu-g*h_uud)/h_uu**2)
  g = -(g/h_uu)
!if (hCone .GE. 0.0D0) then
  hd = hconed*(1.0d0-cont) - hcone*contd + hhatd*cont + hhat*contd + &
&   palphad*g + palpha*gd
  h = hcone*(1.0d0-cont) + hhat*cont + palpha*g
END SUBROUTINE HFUNIMPLICIT_DI

!  Differentiation of pmpcone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: pig
!#######################################################################
!## PMP of the cone
SUBROUTINE PMPCONE_DI(pig, pigd, sdir, fcone, u, ud)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), sdir(3), fcone(2)
  DOUBLE PRECISION, INTENT(IN) :: pigd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
! local variables
  DOUBLE PRECISION :: sperp(3)
  DOUBLE PRECISION :: sperpd(3)
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  sperpd = pigd - sdir*(sdir(1)*pigd(1)+sdir(2)*pigd(2)+sdir(3)*pigd(3))
  sperp = pig - (pig(1)*sdir(1)+pig(2)*sdir(2)+pig(3)*sdir(3))*sdir
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.D0
  ELSE
    result1d = arg1d/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperp = sperp/result1
  ud = fcone(2)*sperpd
  u = fcone(1)*sdir + fcone(2)*sperp
END SUBROUTINE PMPCONE_DI

!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DI(m, md, i, mu, fx, fxd, fy, fyd, fz, fzd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DI(m, md, i, mu, r, rd, t, td, n, nd, f, fd)
  thetad = fd
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthd = thetad*COS(theta)
  sth = SIN(theta)
  cthd = -(thetad*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DI

!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DI(m, md, i, mu, r, rd, t, td, n, nd, f, fd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DI(e, m, md, f, fd)
! Useful variables
  cfd = -(fd*SIN(f))
  cf = COS(f)
  sfd = fd*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetad = fd
  theta = w + f
! GVEs
  rd(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.D0
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.D0
  t(2) = 0.0d0
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.D0
  rd(3) = -(p*cfd/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.D0
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  t(3) = (p+rad)*sf/h/e
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rd(4) = 2.0d0*a**2*e*sfd/h
  r(4) = 2.0d0*a**2*e*sf/h
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  nd(4) = 0.D0
  n(4) = 0.0d0
  rd(5) = p*sfd/h
  r(5) = p*sf/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  nd(5) = 0.D0
  n(5) = 0.0d0
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  nd(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DI

!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DI(ecc, m, md, f, fd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed, kd, dkd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  e = m
  DO ii=1,nmax
    kd = ed - ecc*ed*COS(e) - md
    k = e - ecc*SIN(e) - m
    dkd = ecc*ed*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    ed = ed - (kd*dk-k*dkd)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DI

!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DI(n, u, ud, v, vd, res, resd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.D0
  DO i=1,n
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DI

!  Differentiation of hfunalpha_da_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h hd hdd
!   with respect to varying inputs: pdeltai m alpha
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunalpha_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hd
!   with respect to varying inputs: alpha
!   RW status of diff variables: alpha:in hd:out
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunalpha in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h
!   with respect to varying inputs: pdeltai m alpha deltai
!   RW status of diff variables: h:out pdeltai:in m:in alpha:in
!                deltai:in
!#######################################################################
!## Hamiltonian
SUBROUTINE HFUNALPHA_DA_DA_DI(m, md0, md, deltai, deltaid, pdeltai, &
& pdeltaid0, pdeltaid, alpha, alphad1, alphad0, alphad, pars, cont, h, &
& hd0, hd, hdd0, hdd, hddd)
  IMPLICIT NONE
!!!!!!!!!
!h = u(1)
!!!!!!!!!
  DOUBLE PRECISION, INTENT(IN) :: m, alpha, deltai(5), pdeltai(5), pars(&
& 11), cont
  DOUBLE PRECISION, INTENT(IN) :: md0, alphad1, pdeltaid0(5)
  DOUBLE PRECISION, INTENT(IN) :: alphad0
  DOUBLE PRECISION, INTENT(IN) :: md, alphad, deltaid(5), pdeltaid(5)
  DOUBLE PRECISION, INTENT(OUT) :: h
  DOUBLE PRECISION, INTENT(OUT) :: hd0
  DOUBLE PRECISION, INTENT(OUT) :: hd
  DOUBLE PRECISION, INTENT(OUT) :: hdd0
  DOUBLE PRECISION, INTENT(OUT) :: hdd
  DOUBLE PRECISION, INTENT(OUT) :: hddd
!local variables
  DOUBLE PRECISION :: mu, i(5), bsail(3), sdir(3)
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3)
  DOUBLE PRECISION :: fxd0(6), fyd0(6), fzd0(6), pigd1(3)
  DOUBLE PRECISION :: pigd0(3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3)
  DOUBLE PRECISION :: fxdd(6), fydd(6), fzdd(6), pigdd0(3)
  DOUBLE PRECISION :: pigdd(3)
  DOUBLE PRECISION :: usail(3), u(3), nnorb, hsail, aaorb
  DOUBLE PRECISION :: usaild1(3), hsaild0
  DOUBLE PRECISION :: usaild0(3)
  DOUBLE PRECISION :: usaild0d(3)
  DOUBLE PRECISION :: usaild(3), hsaild
  DOUBLE PRECISION :: usaildd0(3), hsaildd0
  DOUBLE PRECISION :: usaildd(3), hsaildd
  DOUBLE PRECISION :: usailddd(3), hsailddd
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
! Gravitational constant
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Optical coefficients
  bsail = pars(9:11)
! Direction of the Sun
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
! GVEs
  CALL GVEECI_DA_DI(m, md0, md, i, mu, fx, fxd0, fxd, fxdd, fy, fyd0, &
&             fyd, fydd, fz, fzd0, fzd, fzdd)
  CALL DOT_DA_DI(5, pdeltai, pdeltaid0, pdeltaid, fx, fxd0, fxd, fxdd, &
&          pig(1), pigd1(1), pigd(1), pigdd0(1))
  CALL DOT_DA_DI(5, pdeltai, pdeltaid0, pdeltaid, fy, fyd0, fyd, fydd, &
&          pig(2), pigd1(2), pigd(2), pigdd0(2))
  CALL DOT_DA_DI(5, pdeltai, pdeltaid0, pdeltaid, fz, fzd0, fzd, fzdd, &
&          pig(3), pigd1(3), pigd(3), pigdd0(3))
! Hamiltonian of the sail
  CALL PMPSAIL_DA_DA_DI(pig, pigd1, pigd, pigdd0, sdir, alpha, alphad1, &
&                 alphad0, alphad, bsail, usail, usaild1, usaild0, &
&                 usaild0d, usaild, usaildd0, usaildd, usailddd)
  CALL DOT_DA_DA_DI(3, pig, pigd1, pigd, pigdd0, usail, usaild1, usaild0&
&             , usaild0d, usaild, usaildd0, usaildd, usailddd, hsail, &
&             hsaild0, hsaild, hsaildd0, hsaildd, hsailddd)
  hddd = hsailddd
  hdd = hsaildd
  hdd0 = hsaildd0
  hd = hsaild
  hd0 = hsaild0
  h = hsail
! Mean longitude as time variable
  aaorb = pars(5)
  arg1 = mu/aaorb**3
  nnorb = SQRT(arg1)
  hddd = hddd/nnorb
  hdd = hdd/nnorb
  hdd0 = hdd0/nnorb
  hd = hd/nnorb
  hd0 = hd0/nnorb
  h = h/nnorb
END SUBROUTINE HFUNALPHA_DA_DA_DI

!  Differentiation of gveeci_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fzd fxd fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DA_DI(m, md0, md, i, mu, fx, fxd0, fxd, fxdd, fy, fyd0&
& , fyd, fydd, fz, fzd0, fzd, fzdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0(6), fyd0(6), fzd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd(6), fydd(6), fzdd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd0(6), td0(6), nd0(6), fd0, thetad0, sthd0, cthd0
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  DOUBLE PRECISION :: rdd(6), tdd(6), ndd(6), fdd, thetadd, sthdd, cthdd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DA_DI(m, md0, md, i, mu, r, rd0, rd, rdd, t, td0, td, tdd&
&              , n, nd0, nd, ndd, f, fd0, fd, fdd)
  thetadd = fdd
  thetad = fd
  thetad0 = fd0
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthdd = thetadd*COS(theta) - thetad*thetad0*SIN(theta)
  sthd = thetad*COS(theta)
  sthd0 = thetad0*COS(theta)
  sth = SIN(theta)
  cthdd = -(thetadd*SIN(theta)+thetad*thetad0*COS(theta))
  cthd = -(thetad*SIN(theta))
  cthd0 = -(thetad0*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxdd = rdd*(-(som*ci*sth)+com*cth) + rd*(com*cthd0-som*ci*sthd0) + rd0&
&   *(com*cthd-som*ci*sthd) + r*(com*cthdd-som*ci*sthdd) + tdd*(-(som*ci&
&   *cth)-com*sth) + td*(-(som*ci*cthd0)-com*sthd0) + td0*(-(som*ci*cthd&
&   )-com*sthd) + t*(-(som*ci*cthdd)-com*sthdd) + som*si*ndd
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fxd0 = rd0*(-(som*ci*sth)+com*cth) + r*(com*cthd0-som*ci*sthd0) + td0*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd0)-com*sthd0) + som*si*nd0
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fydd = rdd*(com*ci*sth+som*cth) + rd*(com*ci*sthd0+som*cthd0) + rd0*(&
&   com*ci*sthd+som*cthd) + r*(com*ci*sthdd+som*cthdd) + tdd*(com*ci*cth&
&   -som*sth) + td*(com*ci*cthd0-som*sthd0) + td0*(com*ci*cthd-som*sthd)&
&   + t*(com*ci*cthdd-som*sthdd) - com*si*ndd
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fyd0 = rd0*(com*ci*sth+som*cth) + r*(com*ci*sthd0+som*cthd0) + td0*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd0-som*sthd0) - com*si*nd0
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzdd = si*(rdd*sth+rd*sthd0+rd0*sthd+r*sthdd) + si*(tdd*cth+td*cthd0+&
&   td0*cthd+t*cthdd) + ci*ndd
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fzd0 = si*(rd0*sth+r*sthd0) + si*(td0*cth+t*cthd0) + ci*nd0
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DA_DI

!  Differentiation of gvelvlh_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f nd n r t rd fd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DA_DI(m, md0, md, i, mu, r, rd0, rd, rdd, t, td0, td&
& , tdd, n, nd0, nd, ndd, f, fd0, fd, fdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd0(6), td0(6), nd0(6), fd0
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
  DOUBLE PRECISION, INTENT(OUT) :: rdd(6), tdd(6), ndd(6), fdd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd0, sfd0, radd0, thetad0
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  DOUBLE PRECISION :: cfdd, sfdd, raddd, thetadd
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DA_DI(e, m, md0, md, f, fd0, fd, fdd)
! Useful variables
  cfdd = -(fdd*SIN(f)+fd*fd0*COS(f))
  cfd = -(fd*SIN(f))
  cfd0 = -(fd0*SIN(f))
  cf = COS(f)
  sfdd = fdd*COS(f) - fd*fd0*SIN(f)
  sfd = fd*COS(f)
  sfd0 = fd0*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  raddd = -((p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)/((&
&   1.0d0+e*cf)**2)**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  radd0 = -(p*e*cfd0/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetadd = fdd
  thetad = fd
  thetad0 = fd0
  theta = w + f
! GVEs
  rd(1) = 0.d0
  rd0(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.d0
  td0(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.d0
  ndd = 0.D0
  ndd(1) = (raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*thetad+rad*&
&   thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(inc)
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  nd0 = 0.D0
  nd0(1) = (radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.d0
  rd0(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.d0
  td0(2) = 0.D0
  t(2) = 0.0d0
  ndd(2) = (raddd*COS(theta)-radd*thetad0*SIN(theta)-(radd0*thetad+rad*&
&   thetadd)*SIN(theta)-rad*thetad*thetad0*COS(theta))/h
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  nd0(2) = (radd0*COS(theta)-rad*thetad0*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.d0
  rdd = 0.D0
  rdd(3) = -(p*cfdd/h/e)
  rd(3) = -(p*cfd/h/e)
  rd0 = 0.D0
  rd0(3) = -(p*cfd0/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.d0
  tdd = 0.D0
  tdd(3) = (raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/h/e
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  td0 = 0.D0
  td0(3) = (radd0*sf+(p+rad)*sfd0)/h/e
  t(3) = (p+rad)*sf/h/e
  ndd(3) = -(COS(inc)*(raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*&
&   thetad+rad*thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(&
&   inc))
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  nd0(3) = -(COS(inc)*(radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(&
&   inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rdd(4) = 2.0d0*a**2*e*sfdd/h
  rd(4) = 2.0d0*a**2*e*sfd/h
  rd0(4) = 2.0d0*a**2*e*sfd0/h
  r(4) = 2.0d0*a**2*e*sf/h
  tdd(4) = -((2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/&
&   h)/(rad**2)**2)
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  td0(4) = -(2.0d0*a**2*p*radd0/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  ndd(4) = 0.D0
  nd(4) = 0.d0
  nd0(4) = 0.D0
  n(4) = 0.0d0
  rdd(5) = p*sfdd/h
  rd(5) = p*sfd/h
  rd0(5) = p*sfd0/h
  r(5) = p*sf/h
  tdd(5) = (raddd*cf+radd*cfd0+radd0*cfd+(p+rad)*cfdd+e*raddd)/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  td0(5) = (radd0*cf+(p+rad)*cfd0+e*radd0)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  ndd(5) = 0.D0
  nd(5) = 0.d0
  nd0(5) = 0.D0
  n(5) = 0.0d0
  rdd(6) = p*cfdd - 2.0d0*e*b*raddd/a/h/e
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  rd0(6) = p*cfd0 - 2.0d0*e*b*radd0/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  tdd(6) = -(b*(raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/a/h/e)
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  td0(6) = -(b*(radd0*sf+(p+rad)*sfd0)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  ndd(6) = 0.D0
  nd(6) = 0.d0
  nd0(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DA_DI

!  Differentiation of kepler_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fd
!   with respect to varying inputs: m
!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DA_DI(ecc, m, md0, md, f, fd0, fd, fdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd0
  DOUBLE PRECISION, INTENT(OUT) :: fd
  DOUBLE PRECISION, INTENT(OUT) :: fdd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed0, kd0, dkd0
  DOUBLE PRECISION :: ed, kd, dkd
  DOUBLE PRECISION :: edd, kdd, dkdd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d0
  DOUBLE PRECISION :: arg2d
  DOUBLE PRECISION :: arg2dd
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  ed0 = md0
  e = m
  edd = 0.D0
  DO ii=1,nmax
    kdd = edd - ecc*(edd*COS(e)-ed*ed0*SIN(e))
    kd = ed - ecc*ed*COS(e) - md
    kd0 = ed0 - ecc*ed0*COS(e) - md0
    k = e - ecc*SIN(e) - m
    dkdd = ecc*(edd*SIN(e)+ed*ed0*COS(e))
    dkd = ecc*ed*SIN(e)
    dkd0 = ecc*ed0*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    edd = edd - ((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*dk**2-(kd*dk-k*dkd)*2*&
&     dk*dkd0)/(dk**2)**2
    ed = ed - (kd*dk-k*dkd)/dk**2
    ed0 = ed0 - (kd0*dk-k*dkd0)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1dd = result1*(edd*COS(e/2.0d0)-ed*ed0*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1d0 = result1*ed0*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2dd = -(result2*(edd*SIN(e/2.0d0)+ed*ed0*COS(e/2.0d0)/2.0d0)/2.0d0)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2d0 = -(result2*ed0*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fdd = (2.0d0*(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1&
&   **2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d0+2*arg2*&
&   arg2d0))/(arg1**2+arg2**2)**2
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  fd0 = 2.0d0*(arg1d0*arg2-arg2d0*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DA_DI

!  Differentiation of dot_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd res
!   with respect to varying inputs: u v vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DA_DI(n, u, ud0, ud, v, vd0, vd, vdd, res, resd0, resd, &
& resdd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: vdd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.D0
  resd0 = 0.D0
  DO i=1,n
    resdd = resdd + ud(i)*vd0(i) + ud0(i)*vd(i) + u(i)*vdd(i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd0(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DA_DI

!  Differentiation of pmpsail_da_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud udd ud0
!   with respect to varying inputs: alpha pigd pig
!  Differentiation of pmpsail_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud
!   with respect to varying inputs: alpha
!  Differentiation of pmpsail in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: alpha pig
!#######################################################################
!# PMP of the sail
SUBROUTINE PMPSAIL_DA_DA_DI(pig, pigd0, pigd, pigdd, sdir, alpha, &
& alphad1, alphad0, alphad, b, u, ud1, ud0, ud0d, ud, udd0, udd, uddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), alpha, sdir(3), b(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd0(3), alphad1
  DOUBLE PRECISION, INTENT(IN) :: alphad0
  DOUBLE PRECISION, INTENT(IN) :: pigd(3), alphad
  DOUBLE PRECISION, INTENT(IN) :: pigdd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud1(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0d(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd0(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd(3)
  DOUBLE PRECISION, INTENT(OUT) :: uddd(3)
! local variables
  DOUBLE PRECISION :: b1, b2, b3, pis, pinorm, theta, kpolar, sperp(3), &
& calpha, salpha, fs, fperp
  DOUBLE PRECISION :: pisd0, sperpd0(3), calphad1, salphad1, fsd1, &
& fperpd1
  DOUBLE PRECISION :: calphad0, salphad0, fsd0, fperpd0
  DOUBLE PRECISION :: calphad0d, salphad0d, fsd0d, fperpd0d
  DOUBLE PRECISION :: pisd, sperpd(3), calphad, salphad, fsd, fperpd
  DOUBLE PRECISION :: pisdd, sperpdd(3), calphadd0, salphadd0, fsdd0, &
& fperpdd0
  DOUBLE PRECISION :: calphadd, salphadd, fsdd, fperpdd
  DOUBLE PRECISION :: calphaddd, salphaddd, fsddd, fperpddd
  INTRINSIC SQRT
  INTRINSIC ACOS
  INTRINSIC COS
  INTRINSIC SIN
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d0
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result1dd
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d
  b1 = b(1)
  b2 = b(2)
  b3 = b(3)
  pisdd = sdir(1)*pigdd(1) + sdir(2)*pigdd(2) + sdir(3)*pigdd(3)
  pisd = sdir(1)*pigd(1) + sdir(2)*pigd(2) + sdir(3)*pigd(3)
  pisd0 = sdir(1)*pigd0(1) + sdir(2)*pigd0(2) + sdir(3)*pigd0(3)
  pis = pig(1)*sdir(1) + pig(2)*sdir(2) + pig(3)*sdir(3)
  arg1 = pig(1)**2 + pig(2)**2 + pig(3)**2
  pinorm = SQRT(arg1)
  theta = ACOS(pis/pinorm)
! Definition of the unit vector sPerp
  sperpdd = pigdd - sdir*pisdd
  sperpd = pigd - sdir*pisd
  sperpd0 = pigd0 - sdir*pisd0
  sperp = pig - pis*sdir
! Note: nan for collinear vectors
  arg1dd = 2*(sperpd0(1)*sperpd(1)) + 2*(sperp(1)*sperpdd(1)) + 2*(&
&   sperpd0(2)*sperpd(2)) + 2*(sperp(2)*sperpdd(2)) + 2*(sperpd0(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd(3))
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1d0 = 2*sperp(1)*sperpd0(1) + 2*sperp(2)*sperpd0(2) + 2*sperp(3)*&
&   sperpd0(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
    result1dd = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.D0
    ELSE
      result10d = arg1d0/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    result1dd = (arg1dd*2.0*result10-arg1d*2.0*result10d)/(2.0*result10)&
&     **2
    result1d = arg1d/(2.0*result10)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d0 = 0.D0
  ELSE
    result1d0 = arg1d0/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpdd = ((sperpdd*result1+sperpd*result1d0-sperpd0*result1d-sperp*&
&   result1dd)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d0)/(result1**2)**2
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperpd0 = (sperpd0*result1-sperp*result1d0)/result1**2
  sperp = sperp/result1
  calphaddd = alphad*alphad0*alphad1*SIN(alpha)
  calphadd = -(alphad*alphad0*COS(alpha))
  calphadd0 = -(alphad*alphad1*COS(alpha))
  calphad = -(alphad*SIN(alpha))
  calphad0d = -(alphad0*alphad1*COS(alpha))
  calphad0 = -(alphad0*SIN(alpha))
  calphad1 = -(alphad1*SIN(alpha))
  calpha = COS(alpha)
  salphaddd = -(alphad*alphad0*alphad1*COS(alpha))
  salphadd = -(alphad*alphad0*SIN(alpha))
  salphadd0 = -(alphad*alphad1*SIN(alpha))
  salphad = alphad*COS(alpha)
  salphad0d = -(alphad0*alphad1*SIN(alpha))
  salphad0 = alphad0*COS(alpha)
  salphad1 = alphad1*COS(alpha)
  salpha = SIN(alpha)
! Optimal force
  fsddd = b1*calphaddd + (b2*2*(calphad0d*calphad+calphad0*calphadd0+&
&   calphad1*calphadd+calpha*calphaddd)+b3*calphaddd)*calpha + (b2*2*(&
&   calphad0*calphad+calpha*calphadd)+b3*calphadd)*calphad1 + (b2*2*(&
&   calphad1*calphad+calpha*calphadd0)+b3*calphadd0)*calphad0 + (b2*2*&
&   calpha*calphad+b3*calphad)*calphad0d + (b2*2*(calphad1*calphad0+&
&   calpha*calphad0d)+b3*calphad0d)*calphad + (b2*2*calpha*calphad0+b3*&
&   calphad0)*calphadd0 + (b2*2*calpha*calphad1+b3*calphad1)*calphadd + &
&   (b2*calpha**2+b3*calpha)*calphaddd
  fsdd = b1*calphadd + (b2*2*(calphad0*calphad+calpha*calphadd)+b3*&
&   calphadd)*calpha + (b2*2*calpha*calphad+b3*calphad)*calphad0 + (b2*2&
&   *calpha*calphad0+b3*calphad0)*calphad + (b2*calpha**2+b3*calpha)*&
&   calphadd
  fsdd0 = b1*calphadd0 + (b2*2*(calphad1*calphad+calpha*calphadd0)+b3*&
&   calphadd0)*calpha + (b2*2*calpha*calphad+b3*calphad)*calphad1 + (b2*&
&   2*calpha*calphad1+b3*calphad1)*calphad + (b2*calpha**2+b3*calpha)*&
&   calphadd0
  fsd = b1*calphad + (b2*2*calpha*calphad+b3*calphad)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad
  fsd0d = b1*calphad0d + (b2*2*(calphad1*calphad0+calpha*calphad0d)+b3*&
&   calphad0d)*calpha + (b2*2*calpha*calphad0+b3*calphad0)*calphad1 + (&
&   b2*2*calpha*calphad1+b3*calphad1)*calphad0 + (b2*calpha**2+b3*calpha&
&   )*calphad0d
  fsd0 = b1*calphad0 + (b2*2*calpha*calphad0+b3*calphad0)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad0
  fsd1 = b1*calphad1 + (b2*2*calpha*calphad1+b3*calphad1)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad1
  fs = b1*calpha + (b2*calpha**2+b3*calpha)*calpha
  fperpddd = (b2*2*(calphad0d*calphad+calphad0*calphadd0+calphad1*&
&   calphadd+calpha*calphaddd)+b3*calphaddd)*salpha + (b2*2*(calphad0*&
&   calphad+calpha*calphadd)+b3*calphadd)*salphad1 + (b2*2*(calphad1*&
&   calphad+calpha*calphadd0)+b3*calphadd0)*salphad0 + (b2*2*calpha*&
&   calphad+b3*calphad)*salphad0d + (b2*2*(calphad1*calphad0+calpha*&
&   calphad0d)+b3*calphad0d)*salphad + (b2*2*calpha*calphad0+b3*calphad0&
&   )*salphadd0 + (b2*2*calpha*calphad1+b3*calphad1)*salphadd + (b2*&
&   calpha**2+b3*calpha)*salphaddd
  fperpdd = (b2*2*(calphad0*calphad+calpha*calphadd)+b3*calphadd)*salpha&
&   + (b2*2*calpha*calphad+b3*calphad)*salphad0 + (b2*2*calpha*calphad0+&
&   b3*calphad0)*salphad + (b2*calpha**2+b3*calpha)*salphadd
  fperpdd0 = (b2*2*(calphad1*calphad+calpha*calphadd0)+b3*calphadd0)*&
&   salpha + (b2*2*calpha*calphad+b3*calphad)*salphad1 + (b2*2*calpha*&
&   calphad1+b3*calphad1)*salphad + (b2*calpha**2+b3*calpha)*salphadd0
  fperpd = (b2*2*calpha*calphad+b3*calphad)*salpha + (b2*calpha**2+b3*&
&   calpha)*salphad
  fperpd0d = (b2*2*(calphad1*calphad0+calpha*calphad0d)+b3*calphad0d)*&
&   salpha + (b2*2*calpha*calphad0+b3*calphad0)*salphad1 + (b2*2*calpha*&
&   calphad1+b3*calphad1)*salphad0 + (b2*calpha**2+b3*calpha)*salphad0d
  fperpd0 = (b2*2*calpha*calphad0+b3*calphad0)*salpha + (b2*calpha**2+b3&
&   *calpha)*salphad0
  fperpd1 = (b2*2*calpha*calphad1+b3*calphad1)*salpha + (b2*calpha**2+b3&
&   *calpha)*salphad1
  fperp = (b2*calpha**2+b3*calpha)*salpha
  uddd = sdir*fsddd + sperpd0*fperpdd + sperp*fperpddd + sperpdd*fperpd0&
&   + sperpd*fperpd0d
  udd = sdir*fsdd + sperp*fperpdd + sperpd*fperpd0
  udd0 = sdir*fsdd0 + fperpdd0*sperp + fperpd*sperpd0 + fperpd1*sperpd +&
&   fperp*sperpdd
  ud = sdir*fsd + fperpd*sperp + fperp*sperpd
  ud0d = sdir*fsd0d + sperpd0*fperpd0 + sperp*fperpd0d
  ud0 = sdir*fsd0 + sperp*fperpd0
  ud1 = sdir*fsd1 + fperpd1*sperp + fperp*sperpd0
  u = fs*sdir + fperp*sperp
END SUBROUTINE PMPSAIL_DA_DA_DI

!  Differentiation of dot_da_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resdd resd res
!   with respect to varying inputs: u v ud vd0 vd vdd
!  Differentiation of dot_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd
!   with respect to varying inputs: v vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DA_DA_DI(n, u, ud0, ud, udd, v, vd1, vd0, vd0d, vd, vdd0&
& , vdd, vddd, res, resd0, resd, resdd0, resdd, resddd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd1(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0d(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: udd(n), vdd0(n)
  DOUBLE PRECISION, INTENT(IN) :: vdd(n)
  DOUBLE PRECISION, INTENT(IN) :: vddd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd0
  DOUBLE PRECISION, INTENT(OUT) :: resdd
  DOUBLE PRECISION, INTENT(OUT) :: resddd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.d0
  resddd = 0.D0
  resdd0 = 0.D0
  resd0 = 0.D0
  DO i=1,n
    resddd = resddd + udd(i)*vd0(i) + ud(i)*vd0d(i) + ud0(i)*vdd(i) + u(&
&     i)*vddd(i)
    resdd = resdd + ud(i)*vd0(i) + u(i)*vdd(i)
    resdd0 = resdd0 + udd(i)*v(i) + ud(i)*vd1(i) + ud0(i)*vd(i) + u(i)*&
&     vdd0(i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd1(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DA_DA_DI

!  Differentiation of hfuncone_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hconed
!   with respect to varying inputs: pdeltai m
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfuncone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hcone
!   with respect to varying inputs: pdeltai m
!   RW status of diff variables: pdeltai:in m:in hcone:out
!Calcul of hcone
SUBROUTINE HFUNCONE_DC_DI(m, md0, md, pdeltai, pdeltaid0, pdeltaid, pars&
& , hcone, hconed, hconedd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pdeltai(5), m, pars(11)
  DOUBLE PRECISION, INTENT(IN) :: pdeltaid0(5), md0
  DOUBLE PRECISION, INTENT(IN) :: pdeltaid(5), md
  DOUBLE PRECISION :: pdeltaidd(5)
  DOUBLE PRECISION, INTENT(OUT) :: hcone
  DOUBLE PRECISION :: hconed0
  DOUBLE PRECISION, INTENT(OUT) :: hconed
  DOUBLE PRECISION, INTENT(OUT) :: hconedd
! local variables
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3), sdir(3), mu, fcone(2)&
& , ucone(3), i(5)
  DOUBLE PRECISION :: fxd0(6), fyd0(6), fzd0(6), pigd0(3), uconed0(3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3), uconed(3)
  DOUBLE PRECISION :: fxdd(6), fydd(6), fzdd(6), pigdd(3), uconedd(3)
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Forces on convex cone
  fcone = pars(7:8)
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
  CALL GVEECI_DC_DI(m, md0, md, i, mu, fx, fxd0, fxd, fxdd, fy, fyd0, &
&             fyd, fydd, fz, fzd0, fzd, fzdd)
  pdeltaidd = 0.D0
  CALL DOT_DC_DI(5, pdeltai, pdeltaid0, pdeltaid, pdeltaidd, fx, fxd0, &
&          fxd, fxdd, pig(1), pigd0(1), pigd(1), pigdd(1))
  pdeltaidd = 0.D0
  CALL DOT_DC_DI(5, pdeltai, pdeltaid0, pdeltaid, pdeltaidd, fy, fyd0, &
&          fyd, fydd, pig(2), pigd0(2), pigd(2), pigdd(2))
  pdeltaidd = 0.D0
  CALL DOT_DC_DI(5, pdeltai, pdeltaid0, pdeltaid, pdeltaidd, fz, fzd0, &
&          fzd, fzdd, pig(3), pigd0(3), pigd(3), pigdd(3))
! Hamiltonian of the cone
  CALL PMPCONE_DC_DI(pig, pigd0, pigd, pigdd, sdir, fcone, ucone, &
&              uconed0, uconed, uconedd)
  CALL DOT_DC_DI(3, pig, pigd0, pigd, pigdd, ucone, uconed0, uconed, &
&          uconedd, hcone, hconed0, hconed, hconedd)
END SUBROUTINE HFUNCONE_DC_DI

!  Differentiation of pmpcone_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud
!   with respect to varying inputs: pigd pig
!  Differentiation of pmpcone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: pig
!#######################################################################
!## PMP of the cone
SUBROUTINE PMPCONE_DC_DI(pig, pigd0, pigd, pigdd, sdir, fcone, u, ud0, &
& ud, udd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), sdir(3), fcone(2)
  DOUBLE PRECISION, INTENT(IN) :: pigd0(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd(3)
  DOUBLE PRECISION, INTENT(IN) :: pigdd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd(3)
! local variables
  DOUBLE PRECISION :: sperp(3)
  DOUBLE PRECISION :: sperpd0(3)
  DOUBLE PRECISION :: sperpd(3)
  DOUBLE PRECISION :: sperpdd(3)
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d0
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result1dd
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d
  sperpdd = pigdd - sdir*(sdir(1)*pigdd(1)+sdir(2)*pigdd(2)+sdir(3)*&
&   pigdd(3))
  sperpd = pigd - sdir*(sdir(1)*pigd(1)+sdir(2)*pigd(2)+sdir(3)*pigd(3))
  sperpd0 = pigd0 - sdir*(sdir(1)*pigd0(1)+sdir(2)*pigd0(2)+sdir(3)*&
&   pigd0(3))
  sperp = pig - (pig(1)*sdir(1)+pig(2)*sdir(2)+pig(3)*sdir(3))*sdir
  arg1dd = 2*(sperpd0(1)*sperpd(1)) + 2*(sperp(1)*sperpdd(1)) + 2*(&
&   sperpd0(2)*sperpd(2)) + 2*(sperp(2)*sperpdd(2)) + 2*(sperpd0(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd(3))
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1d0 = 2*sperp(1)*sperpd0(1) + 2*sperp(2)*sperpd0(2) + 2*sperp(3)*&
&   sperpd0(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
    result1dd = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.D0
    ELSE
      result10d = arg1d0/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    result1dd = (arg1dd*2.0*result10-arg1d*2.0*result10d)/(2.0*result10)&
&     **2
    result1d = arg1d/(2.0*result10)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d0 = 0.D0
  ELSE
    result1d0 = arg1d0/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpdd = ((sperpdd*result1+sperpd*result1d0-sperpd0*result1d-sperp*&
&   result1dd)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d0)/(result1**2)**2
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperpd0 = (sperpd0*result1-sperp*result1d0)/result1**2
  sperp = sperp/result1
  udd = fcone(2)*sperpdd
  ud = fcone(2)*sperpd
  ud0 = fcone(2)*sperpd0
  u = fcone(1)*sdir + fcone(2)*sperp
END SUBROUTINE PMPCONE_DC_DI

!  Differentiation of gveeci_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fzd fxd fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DC_DI(m, md0, md, i, mu, fx, fxd0, fxd, fxdd, fy, fyd0&
& , fyd, fydd, fz, fzd0, fzd, fzdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0(6), fyd0(6), fzd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd(6), fydd(6), fzdd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd0(6), td0(6), nd0(6), fd0, thetad0, sthd0, cthd0
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  DOUBLE PRECISION :: rdd(6), tdd(6), ndd(6), fdd, thetadd, sthdd, cthdd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DC_DI(m, md0, md, i, mu, r, rd0, rd, rdd, t, td0, td, tdd&
&              , n, nd0, nd, ndd, f, fd0, fd, fdd)
  thetadd = fdd
  thetad = fd
  thetad0 = fd0
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthdd = thetadd*COS(theta) - thetad*thetad0*SIN(theta)
  sthd = thetad*COS(theta)
  sthd0 = thetad0*COS(theta)
  sth = SIN(theta)
  cthdd = -(thetadd*SIN(theta)+thetad*thetad0*COS(theta))
  cthd = -(thetad*SIN(theta))
  cthd0 = -(thetad0*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxdd = rdd*(-(som*ci*sth)+com*cth) + rd*(com*cthd0-som*ci*sthd0) + rd0&
&   *(com*cthd-som*ci*sthd) + r*(com*cthdd-som*ci*sthdd) + tdd*(-(som*ci&
&   *cth)-com*sth) + td*(-(som*ci*cthd0)-com*sthd0) + td0*(-(som*ci*cthd&
&   )-com*sthd) + t*(-(som*ci*cthdd)-com*sthdd) + som*si*ndd
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fxd0 = rd0*(-(som*ci*sth)+com*cth) + r*(com*cthd0-som*ci*sthd0) + td0*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd0)-com*sthd0) + som*si*nd0
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fydd = rdd*(com*ci*sth+som*cth) + rd*(com*ci*sthd0+som*cthd0) + rd0*(&
&   com*ci*sthd+som*cthd) + r*(com*ci*sthdd+som*cthdd) + tdd*(com*ci*cth&
&   -som*sth) + td*(com*ci*cthd0-som*sthd0) + td0*(com*ci*cthd-som*sthd)&
&   + t*(com*ci*cthdd-som*sthdd) - com*si*ndd
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fyd0 = rd0*(com*ci*sth+som*cth) + r*(com*ci*sthd0+som*cthd0) + td0*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd0-som*sthd0) - com*si*nd0
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzdd = si*(rdd*sth+rd*sthd0+rd0*sthd+r*sthdd) + si*(tdd*cth+td*cthd0+&
&   td0*cthd+t*cthdd) + ci*ndd
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fzd0 = si*(rd0*sth+r*sthd0) + si*(td0*cth+t*cthd0) + ci*nd0
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DC_DI

!  Differentiation of gvelvlh_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f nd n r t rd fd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DC_DI(m, md0, md, i, mu, r, rd0, rd, rdd, t, td0, td&
& , tdd, n, nd0, nd, ndd, f, fd0, fd, fdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd0(6), td0(6), nd0(6), fd0
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
  DOUBLE PRECISION, INTENT(OUT) :: rdd(6), tdd(6), ndd(6), fdd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd0, sfd0, radd0, thetad0
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  DOUBLE PRECISION :: cfdd, sfdd, raddd, thetadd
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DC_DI(e, m, md0, md, f, fd0, fd, fdd)
! Useful variables
  cfdd = -(fdd*SIN(f)+fd*fd0*COS(f))
  cfd = -(fd*SIN(f))
  cfd0 = -(fd0*SIN(f))
  cf = COS(f)
  sfdd = fdd*COS(f) - fd*fd0*SIN(f)
  sfd = fd*COS(f)
  sfd0 = fd0*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  raddd = -((p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)/((&
&   1.0d0+e*cf)**2)**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  radd0 = -(p*e*cfd0/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetadd = fdd
  thetad = fd
  thetad0 = fd0
  theta = w + f
! GVEs
  rd(1) = 0.d0
  rd0(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.d0
  td0(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.d0
  ndd = 0.D0
  ndd(1) = (raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*thetad+rad*&
&   thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(inc)
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  nd0 = 0.D0
  nd0(1) = (radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.d0
  rd0(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.d0
  td0(2) = 0.D0
  t(2) = 0.0d0
  ndd(2) = (raddd*COS(theta)-radd*thetad0*SIN(theta)-(radd0*thetad+rad*&
&   thetadd)*SIN(theta)-rad*thetad*thetad0*COS(theta))/h
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  nd0(2) = (radd0*COS(theta)-rad*thetad0*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.d0
  rdd = 0.D0
  rdd(3) = -(p*cfdd/h/e)
  rd(3) = -(p*cfd/h/e)
  rd0 = 0.D0
  rd0(3) = -(p*cfd0/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.d0
  tdd = 0.D0
  tdd(3) = (raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/h/e
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  td0 = 0.D0
  td0(3) = (radd0*sf+(p+rad)*sfd0)/h/e
  t(3) = (p+rad)*sf/h/e
  ndd(3) = -(COS(inc)*(raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*&
&   thetad+rad*thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(&
&   inc))
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  nd0(3) = -(COS(inc)*(radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(&
&   inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rdd(4) = 2.0d0*a**2*e*sfdd/h
  rd(4) = 2.0d0*a**2*e*sfd/h
  rd0(4) = 2.0d0*a**2*e*sfd0/h
  r(4) = 2.0d0*a**2*e*sf/h
  tdd(4) = -((2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/&
&   h)/(rad**2)**2)
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  td0(4) = -(2.0d0*a**2*p*radd0/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  ndd(4) = 0.D0
  nd(4) = 0.d0
  nd0(4) = 0.D0
  n(4) = 0.0d0
  rdd(5) = p*sfdd/h
  rd(5) = p*sfd/h
  rd0(5) = p*sfd0/h
  r(5) = p*sf/h
  tdd(5) = (raddd*cf+radd*cfd0+radd0*cfd+(p+rad)*cfdd+e*raddd)/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  td0(5) = (radd0*cf+(p+rad)*cfd0+e*radd0)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  ndd(5) = 0.D0
  nd(5) = 0.d0
  nd0(5) = 0.D0
  n(5) = 0.0d0
  rdd(6) = p*cfdd - 2.0d0*e*b*raddd/a/h/e
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  rd0(6) = p*cfd0 - 2.0d0*e*b*radd0/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  tdd(6) = -(b*(raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/a/h/e)
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  td0(6) = -(b*(radd0*sf+(p+rad)*sfd0)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  ndd(6) = 0.D0
  nd(6) = 0.d0
  nd0(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DC_DI

!  Differentiation of kepler_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fd
!   with respect to varying inputs: m
!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DC_DI(ecc, m, md0, md, f, fd0, fd, fdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd0
  DOUBLE PRECISION, INTENT(OUT) :: fd
  DOUBLE PRECISION, INTENT(OUT) :: fdd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed0, kd0, dkd0
  DOUBLE PRECISION :: ed, kd, dkd
  DOUBLE PRECISION :: edd, kdd, dkdd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d0
  DOUBLE PRECISION :: arg2d
  DOUBLE PRECISION :: arg2dd
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  ed0 = md0
  e = m
  edd = 0.D0
  DO ii=1,nmax
    kdd = edd - ecc*(edd*COS(e)-ed*ed0*SIN(e))
    kd = ed - ecc*ed*COS(e) - md
    kd0 = ed0 - ecc*ed0*COS(e) - md0
    k = e - ecc*SIN(e) - m
    dkdd = ecc*(edd*SIN(e)+ed*ed0*COS(e))
    dkd = ecc*ed*SIN(e)
    dkd0 = ecc*ed0*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    edd = edd - ((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*dk**2-(kd*dk-k*dkd)*2*&
&     dk*dkd0)/(dk**2)**2
    ed = ed - (kd*dk-k*dkd)/dk**2
    ed0 = ed0 - (kd0*dk-k*dkd0)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1dd = result1*(edd*COS(e/2.0d0)-ed*ed0*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1d0 = result1*ed0*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2dd = -(result2*(edd*SIN(e/2.0d0)+ed*ed0*COS(e/2.0d0)/2.0d0)/2.0d0)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2d0 = -(result2*ed0*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fdd = (2.0d0*(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1&
&   **2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d0+2*arg2*&
&   arg2d0))/(arg1**2+arg2**2)**2
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  fd0 = 2.0d0*(arg1d0*arg2-arg2d0*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DC_DI

!  Differentiation of dot_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd res
!   with respect to varying inputs: u v ud vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DC_DI(n, u, ud0, ud, udd, v, vd0, vd, vdd, res, resd0, &
& resd, resdd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: udd(n), vdd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.D0
  resd0 = 0.D0
  DO i=1,n
    resdd = resdd + udd(i)*v(i) + ud(i)*vd0(i) + ud0(i)*vd(i) + u(i)*vdd&
&     (i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd0(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DC_DI

