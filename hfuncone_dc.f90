!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfuncone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hcone
!   with respect to varying inputs: pdeltai m
!   RW status of diff variables: pdeltai:in m:in hcone:out
!Calcul of hcone
SUBROUTINE HFUNCONE_DC(m, md, pdeltai, pdeltaid, pars, hcone, hconed)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pdeltai(5), m, pars(11)
  DOUBLE PRECISION, INTENT(IN) :: pdeltaid(5), md
  DOUBLE PRECISION, INTENT(OUT) :: hcone
  DOUBLE PRECISION, INTENT(OUT) :: hconed
! local variables
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3), sdir(3), mu, fcone(2)&
& , ucone(3), i(5)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3), uconed(3)
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Forces on convex cone
  fcone = pars(7:8)
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
  CALL GVEECI_DC(m, md, i, mu, fx, fxd, fy, fyd, fz, fzd)
  CALL DOT_DC(5, pdeltai, pdeltaid, fx, fxd, pig(1), pigd(1))
  CALL DOT_DC(5, pdeltai, pdeltaid, fy, fyd, pig(2), pigd(2))
  CALL DOT_DC(5, pdeltai, pdeltaid, fz, fzd, pig(3), pigd(3))
! Hamiltonian of the cone
  CALL PMPCONE_DC(pig, pigd, sdir, fcone, ucone, uconed)
  CALL DOT_DC(3, pig, pigd, ucone, uconed, hcone, hconed)
END SUBROUTINE HFUNCONE_DC

!  Differentiation of pmpcone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: pig
!#######################################################################
!## PMP of the cone
SUBROUTINE PMPCONE_DC(pig, pigd, sdir, fcone, u, ud)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), sdir(3), fcone(2)
  DOUBLE PRECISION, INTENT(IN) :: pigd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
! local variables
  DOUBLE PRECISION :: sperp(3)
  DOUBLE PRECISION :: sperpd(3)
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  sperpd = pigd - sdir*(sdir(1)*pigd(1)+sdir(2)*pigd(2)+sdir(3)*pigd(3))
  sperp = pig - (pig(1)*sdir(1)+pig(2)*sdir(2)+pig(3)*sdir(3))*sdir
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.D0
  ELSE
    result1d = arg1d/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperp = sperp/result1
  ud = fcone(2)*sperpd
  u = fcone(1)*sdir + fcone(2)*sperp
END SUBROUTINE PMPCONE_DC

!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DC(m, md, i, mu, fx, fxd, fy, fyd, fz, fzd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DC(m, md, i, mu, r, rd, t, td, n, nd, f, fd)
  thetad = fd
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthd = thetad*COS(theta)
  sth = SIN(theta)
  cthd = -(thetad*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DC

!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DC(m, md, i, mu, r, rd, t, td, n, nd, f, fd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DC(e, m, md, f, fd)
! Useful variables
  cfd = -(fd*SIN(f))
  cf = COS(f)
  sfd = fd*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetad = fd
  theta = w + f
! GVEs
  rd(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.D0
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.D0
  t(2) = 0.0d0
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.D0
  rd(3) = -(p*cfd/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.D0
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  t(3) = (p+rad)*sf/h/e
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rd(4) = 2.0d0*a**2*e*sfd/h
  r(4) = 2.0d0*a**2*e*sf/h
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  nd(4) = 0.D0
  n(4) = 0.0d0
  rd(5) = p*sfd/h
  r(5) = p*sf/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  nd(5) = 0.D0
  n(5) = 0.0d0
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  nd(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DC

!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DC(ecc, m, md, f, fd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed, kd, dkd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  e = m
  DO ii=1,nmax
    kd = ed - ecc*ed*COS(e) - md
    k = e - ecc*SIN(e) - m
    dkd = ecc*ed*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    ed = ed - (kd*dk-k*dkd)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DC

!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DC(n, u, ud, v, vd, res, resd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.D0
  DO i=1,n
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DC

