!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunimplicit_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hd
!   with respect to varying inputs: cont m p q
!   RW status of diff variables: cont:in m:in p:in q:in hd:out
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunimplicit in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h
!   with respect to varying inputs: cont m p q
!   RW status of diff variables: h:out cont:in m:in p:in q:in
SUBROUTINE HFUNIMPLICIT_DI_DI(m, md0, md, q, qd0, qd, p, pd0, pd, pars, &
& cont, contd0, contd, h, hd, hdd)
  IMPLICIT NONE
!else
!   h       = 0.0D0
!end if
!implicit none
  DOUBLE PRECISION, INTENT(IN) :: m, q(6), p(6), pars(11), cont
  DOUBLE PRECISION, INTENT(IN) :: md0, qd0(6), pd0(6), contd0
  DOUBLE PRECISION, INTENT(IN) :: md, qd(6), pd(6), contd
  DOUBLE PRECISION, INTENT(OUT) :: h
  DOUBLE PRECISION, INTENT(OUT) :: hd
  DOUBLE PRECISION, INTENT(OUT) :: hdd
!local variables
  DOUBLE PRECISION :: hhat, g, nnorb, mu, palpha, alpha, deltai(5), &
& pdeltai(5), dum, h_u, h_p, h_cp, h_ci
  DOUBLE PRECISION :: hhatd0, gd0, palphad0, alphad0, pdeltaid0(5), &
& dumd0, h_ud0, h_pd0, h_cpd0
  DOUBLE PRECISION :: hhatd, gd, palphad, alphad, pdeltaid(5), dumd, &
& h_ud, h_pd, h_cpd
  DOUBLE PRECISION :: hhatdd, gdd, pdeltaidd(5), dumdd, h_udd, h_pdd, &
& h_cpdd
  DOUBLE PRECISION :: h_i, h_m, h_uu, h_pu, h_iu, h_mu, ddeltai(5), &
& dpdeltai(5)
  DOUBLE PRECISION :: h_id0, h_md0, h_uud0, h_pud0, h_iud0, h_mud0, &
& dpdeltaid0(5)
  DOUBLE PRECISION :: h_id, h_md, h_uud, h_pud, h_iud, h_mud, dpdeltaid(&
& 5)
  DOUBLE PRECISION :: h_idd, h_mdd, h_uudd, h_pudd, h_iudd, h_mudd
  DOUBLE PRECISION :: i(5), bsail(3), sdir(3)
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3)
  DOUBLE PRECISION :: fxd0(6), fyd0(6), fzd0(6), pigd0(3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3)
  DOUBLE PRECISION :: fxdd(6), fydd(6), fzdd(6), pigdd(3)
  DOUBLE PRECISION :: hsail
  DOUBLE PRECISION :: fcone(2), ucone(3), hcone
  DOUBLE PRECISION :: uconed0(3), hconed0
  DOUBLE PRECISION :: uconed(3), hconed
  DOUBLE PRECISION :: uconedd(3), hconedd
  INTEGER :: idx
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Forces on convex cone
  fcone = pars(7:8)
! Optical coefficients
  bsail = pars(9:11)
  deltai = q(1:5)
  alphad = qd(6)
  alphad0 = qd0(6)
  alpha = q(6)
  pdeltaid = pd(1:5)
  pdeltaid0 = pd0(1:5)
  pdeltai = p(1:5)
  palphad = pd(6)
  palphad0 = pd0(6)
  palpha = p(6)
! Direction of the Sun
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
! GVEs
  CALL GVEECI_DI_DI(m, md0, md, i, mu, fx, fxd0, fxd, fxdd, fy, fyd0, &
&             fyd, fydd, fz, fzd0, fzd, fzdd)
  pdeltaidd = 0.D0
  CALL DOT_DI_DI(5, pdeltai, pdeltaid0, pdeltaid, pdeltaidd, fx, fxd0, &
&          fxd, fxdd, pig(1), pigd0(1), pigd(1), pigdd(1))
  pdeltaidd = 0.D0
  CALL DOT_DI_DI(5, pdeltai, pdeltaid0, pdeltaid, pdeltaidd, fy, fyd0, &
&          fyd, fydd, pig(2), pigd0(2), pigd(2), pigdd(2))
  pdeltaidd = 0.D0
  CALL DOT_DI_DI(5, pdeltai, pdeltaid0, pdeltaid, pdeltaidd, fz, fzd0, &
&          fzd, fzdd, pig(3), pigd0(3), pigd(3), pigdd(3))
! Hamiltonian of the cone
  CALL PMPCONE_DI_DI(pig, pigd0, pigd, pigdd, sdir, fcone, ucone, &
&              uconed0, uconed, uconedd)
  CALL DOT_DI_DI(3, pig, pigd0, pigd, pigdd, ucone, uconed0, uconed, &
&          uconedd, hcone, hconed0, hconed, hconedd)
!-------------------------------------------------
  ddeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
  dpdeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
!call hfunalpha_d(M, deltaI, ddeltaI, pdeltaI, dpdeltaI, alpha, 1.0D0, dum, h_u)
  CALL HFUNALPHA_DA_DA_DI_DI(m, md0, md, 0.0d0, deltai, ddeltai, pdeltai&
&                      , pdeltaid0, pdeltaid, dpdeltai, alpha, alphad0, &
&                      alphad, 1.0d0, 1.0d0, pars, cont, hhat, hhatd0, &
&                      hhatd, hhatdd, h_u, h_ud0, h_ud, h_udd, h_uu, &
&                      h_uud0, h_uud, h_uudd)
!call hfunalpha_da(M, 1.0D0, deltaI, ddeltaI, pdeltaI, dpdeltaI, alpha, 0.0D0, pars, cont, dum, h_m)
  CALL HFUNALPHA_DA_DA_DI_DI(m, md0, md, 1.0d0, deltai, ddeltai, pdeltai&
&                      , pdeltaid0, pdeltaid, dpdeltai, alpha, alphad0, &
&                      alphad, 1.0d0, 0.0d0, pars, cont, dum, dumd0, &
&                      dumd, dumdd, h_m, h_md0, h_md, h_mdd, h_mu, &
&                      h_mud0, h_mud, h_mudd)
  gdd = h_mudd
  gd = h_mud
  gd0 = h_mud0
  g = h_mu
  DO idx=1,5
    ddeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    dpdeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    ddeltai(idx) = 1.0d0
    CALL HFUNALPHA_DA_DA_DI_DI(m, md0, md, 0.0d0, deltai, ddeltai, &
&                        pdeltai, pdeltaid0, pdeltaid, dpdeltai, alpha, &
&                        alphad0, alphad, 1.0d0, 0.0d0, pars, cont, dum&
&                        , dumd0, dumd, dumdd, h_i, h_id0, h_id, h_idd, &
&                        h_iu, h_iud0, h_iud, h_iudd)
    ddeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    dpdeltai = (/0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/)
    dpdeltaid(idx) = 0.d0
    dpdeltaid0(idx) = 0.D0
    dpdeltai(idx) = 1.0d0
    CALL HFUNALPHA_DA_DA_DI_DI(m, md0, md, 0.0d0, deltai, ddeltai, &
&                        pdeltai, pdeltaid0, pdeltaid, dpdeltai, alpha, &
&                        alphad0, alphad, 1.0d0, 0.0d0, pars, cont, dum&
&                        , dumd0, dumd, dumdd, h_p, h_pd0, h_pd, h_pdd, &
&                        h_pu, h_pud0, h_pud, h_pudd)
    CALL HFUNCONE_DC_DI_DI(m, md0, md, 0.0, pdeltai, pdeltaid0, pdeltaid&
&                    , dpdeltai, pars, dum, h_cp, h_cpd0, h_cpd, h_cpdd)
    gdd = gdd + h_iudd*(h_cp*(1.0d0-cont)+h_p*cont) + h_iud*(h_cpd0*(&
&     1.0d0-cont)-h_cp*contd0+h_pd0*cont+h_p*contd0) + h_iud0*(h_cpd*(&
&     1.0d0-cont)-h_cp*contd+h_pd*cont+h_p*contd) + h_iu*(h_cpdd*(1.0d0-&
&     cont)-h_cpd*contd0-contd*h_cpd0+h_pdd*cont+h_pd*contd0+contd*h_pd0&
&     ) - h_pudd*h_i - h_pud*h_id0 - h_pud0*h_id - h_pu*h_idd
    gd = gd + h_iud*(h_cp*(1.0d0-cont)+h_p*cont) + h_iu*(h_cpd*(1.0d0-&
&     cont)-h_cp*contd+h_pd*cont+h_p*contd) - h_pud*h_i - h_pu*h_id
    gd0 = gd0 + h_iud0*(h_cp*(1.0d0-cont)+h_p*cont) + h_iu*(h_cpd0*(&
&     1.0d0-cont)-h_cp*contd0+h_pd0*cont+h_p*contd0) - h_pud0*h_i - h_pu&
&     *h_id0
    g = g + (h_iu*(h_cp*(1.0d0-cont)+h_p*cont)-h_pu*h_i)
  END DO
  gdd = -(((gdd*h_uu+gd*h_uud0-gd0*h_uud-g*h_uudd)*h_uu**2-(gd*h_uu-g*&
&   h_uud)*2*h_uu*h_uud0)/(h_uu**2)**2)
  gd = -((gd*h_uu-g*h_uud)/h_uu**2)
  gd0 = -((gd0*h_uu-g*h_uud0)/h_uu**2)
  g = -(g/h_uu)
!if (hCone .GE. 0.0D0) then
  hdd = hconedd*(1.0d0-cont) - hconed*contd0 - contd*hconed0 + hhatdd*&
&   cont + hhatd*contd0 + contd*hhatd0 + palphad*gd0 + palphad0*gd + &
&   palpha*gdd
  hd = hconed*(1.0d0-cont) - hcone*contd + hhatd*cont + hhat*contd + &
&   palphad*g + palpha*gd
  h = hcone*(1.0d0-cont) + hhat*cont + palpha*g
END SUBROUTINE HFUNIMPLICIT_DI_DI

!  Differentiation of pmpcone_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud
!   with respect to varying inputs: pigd pig
!  Differentiation of pmpcone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: pig
!#######################################################################
!## PMP of the cone
SUBROUTINE PMPCONE_DI_DI(pig, pigd0, pigd, pigdd, sdir, fcone, u, ud0, &
& ud, udd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), sdir(3), fcone(2)
  DOUBLE PRECISION, INTENT(IN) :: pigd0(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd(3)
  DOUBLE PRECISION, INTENT(IN) :: pigdd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd(3)
! local variables
  DOUBLE PRECISION :: sperp(3)
  DOUBLE PRECISION :: sperpd0(3)
  DOUBLE PRECISION :: sperpd(3)
  DOUBLE PRECISION :: sperpdd(3)
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d0
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result1dd
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d
  sperpdd = pigdd - sdir*(sdir(1)*pigdd(1)+sdir(2)*pigdd(2)+sdir(3)*&
&   pigdd(3))
  sperpd = pigd - sdir*(sdir(1)*pigd(1)+sdir(2)*pigd(2)+sdir(3)*pigd(3))
  sperpd0 = pigd0 - sdir*(sdir(1)*pigd0(1)+sdir(2)*pigd0(2)+sdir(3)*&
&   pigd0(3))
  sperp = pig - (pig(1)*sdir(1)+pig(2)*sdir(2)+pig(3)*sdir(3))*sdir
  arg1dd = 2*(sperpd0(1)*sperpd(1)) + 2*(sperp(1)*sperpdd(1)) + 2*(&
&   sperpd0(2)*sperpd(2)) + 2*(sperp(2)*sperpdd(2)) + 2*(sperpd0(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd(3))
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1d0 = 2*sperp(1)*sperpd0(1) + 2*sperp(2)*sperpd0(2) + 2*sperp(3)*&
&   sperpd0(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
    result1dd = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.D0
    ELSE
      result10d = arg1d0/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    result1dd = (arg1dd*2.0*result10-arg1d*2.0*result10d)/(2.0*result10)&
&     **2
    result1d = arg1d/(2.0*result10)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d0 = 0.D0
  ELSE
    result1d0 = arg1d0/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpdd = ((sperpdd*result1+sperpd*result1d0-sperpd0*result1d-sperp*&
&   result1dd)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d0)/(result1**2)**2
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperpd0 = (sperpd0*result1-sperp*result1d0)/result1**2
  sperp = sperp/result1
  udd = fcone(2)*sperpdd
  ud = fcone(2)*sperpd
  ud0 = fcone(2)*sperpd0
  u = fcone(1)*sdir + fcone(2)*sperp
END SUBROUTINE PMPCONE_DI_DI

!  Differentiation of gveeci_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fzd fxd fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DI_DI(m, md0, md, i, mu, fx, fxd0, fxd, fxdd, fy, fyd0&
& , fyd, fydd, fz, fzd0, fzd, fzdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0(6), fyd0(6), fzd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd(6), fydd(6), fzdd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd0(6), td0(6), nd0(6), fd0, thetad0, sthd0, cthd0
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  DOUBLE PRECISION :: rdd(6), tdd(6), ndd(6), fdd, thetadd, sthdd, cthdd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DI_DI(m, md0, md, i, mu, r, rd0, rd, rdd, t, td0, td, tdd&
&              , n, nd0, nd, ndd, f, fd0, fd, fdd)
  thetadd = fdd
  thetad = fd
  thetad0 = fd0
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthdd = thetadd*COS(theta) - thetad*thetad0*SIN(theta)
  sthd = thetad*COS(theta)
  sthd0 = thetad0*COS(theta)
  sth = SIN(theta)
  cthdd = -(thetadd*SIN(theta)+thetad*thetad0*COS(theta))
  cthd = -(thetad*SIN(theta))
  cthd0 = -(thetad0*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxdd = rdd*(-(som*ci*sth)+com*cth) + rd*(com*cthd0-som*ci*sthd0) + rd0&
&   *(com*cthd-som*ci*sthd) + r*(com*cthdd-som*ci*sthdd) + tdd*(-(som*ci&
&   *cth)-com*sth) + td*(-(som*ci*cthd0)-com*sthd0) + td0*(-(som*ci*cthd&
&   )-com*sthd) + t*(-(som*ci*cthdd)-com*sthdd) + som*si*ndd
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fxd0 = rd0*(-(som*ci*sth)+com*cth) + r*(com*cthd0-som*ci*sthd0) + td0*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd0)-com*sthd0) + som*si*nd0
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fydd = rdd*(com*ci*sth+som*cth) + rd*(com*ci*sthd0+som*cthd0) + rd0*(&
&   com*ci*sthd+som*cthd) + r*(com*ci*sthdd+som*cthdd) + tdd*(com*ci*cth&
&   -som*sth) + td*(com*ci*cthd0-som*sthd0) + td0*(com*ci*cthd-som*sthd)&
&   + t*(com*ci*cthdd-som*sthdd) - com*si*ndd
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fyd0 = rd0*(com*ci*sth+som*cth) + r*(com*ci*sthd0+som*cthd0) + td0*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd0-som*sthd0) - com*si*nd0
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzdd = si*(rdd*sth+rd*sthd0+rd0*sthd+r*sthdd) + si*(tdd*cth+td*cthd0+&
&   td0*cthd+t*cthdd) + ci*ndd
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fzd0 = si*(rd0*sth+r*sthd0) + si*(td0*cth+t*cthd0) + ci*nd0
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DI_DI

!  Differentiation of gvelvlh_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f nd n r t rd fd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DI_DI(m, md0, md, i, mu, r, rd0, rd, rdd, t, td0, td&
& , tdd, n, nd0, nd, ndd, f, fd0, fd, fdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd0(6), td0(6), nd0(6), fd0
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
  DOUBLE PRECISION, INTENT(OUT) :: rdd(6), tdd(6), ndd(6), fdd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd0, sfd0, radd0, thetad0
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  DOUBLE PRECISION :: cfdd, sfdd, raddd, thetadd
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DI_DI(e, m, md0, md, f, fd0, fd, fdd)
! Useful variables
  cfdd = -(fdd*SIN(f)+fd*fd0*COS(f))
  cfd = -(fd*SIN(f))
  cfd0 = -(fd0*SIN(f))
  cf = COS(f)
  sfdd = fdd*COS(f) - fd*fd0*SIN(f)
  sfd = fd*COS(f)
  sfd0 = fd0*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  raddd = -((p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)/((&
&   1.0d0+e*cf)**2)**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  radd0 = -(p*e*cfd0/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetadd = fdd
  thetad = fd
  thetad0 = fd0
  theta = w + f
! GVEs
  rd(1) = 0.d0
  rd0(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.d0
  td0(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.d0
  ndd = 0.D0
  ndd(1) = (raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*thetad+rad*&
&   thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(inc)
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  nd0 = 0.D0
  nd0(1) = (radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.d0
  rd0(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.d0
  td0(2) = 0.D0
  t(2) = 0.0d0
  ndd(2) = (raddd*COS(theta)-radd*thetad0*SIN(theta)-(radd0*thetad+rad*&
&   thetadd)*SIN(theta)-rad*thetad*thetad0*COS(theta))/h
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  nd0(2) = (radd0*COS(theta)-rad*thetad0*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.d0
  rdd = 0.D0
  rdd(3) = -(p*cfdd/h/e)
  rd(3) = -(p*cfd/h/e)
  rd0 = 0.D0
  rd0(3) = -(p*cfd0/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.d0
  tdd = 0.D0
  tdd(3) = (raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/h/e
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  td0 = 0.D0
  td0(3) = (radd0*sf+(p+rad)*sfd0)/h/e
  t(3) = (p+rad)*sf/h/e
  ndd(3) = -(COS(inc)*(raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*&
&   thetad+rad*thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(&
&   inc))
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  nd0(3) = -(COS(inc)*(radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(&
&   inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rdd(4) = 2.0d0*a**2*e*sfdd/h
  rd(4) = 2.0d0*a**2*e*sfd/h
  rd0(4) = 2.0d0*a**2*e*sfd0/h
  r(4) = 2.0d0*a**2*e*sf/h
  tdd(4) = -((2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/&
&   h)/(rad**2)**2)
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  td0(4) = -(2.0d0*a**2*p*radd0/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  ndd(4) = 0.D0
  nd(4) = 0.d0
  nd0(4) = 0.D0
  n(4) = 0.0d0
  rdd(5) = p*sfdd/h
  rd(5) = p*sfd/h
  rd0(5) = p*sfd0/h
  r(5) = p*sf/h
  tdd(5) = (raddd*cf+radd*cfd0+radd0*cfd+(p+rad)*cfdd+e*raddd)/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  td0(5) = (radd0*cf+(p+rad)*cfd0+e*radd0)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  ndd(5) = 0.D0
  nd(5) = 0.d0
  nd0(5) = 0.D0
  n(5) = 0.0d0
  rdd(6) = p*cfdd - 2.0d0*e*b*raddd/a/h/e
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  rd0(6) = p*cfd0 - 2.0d0*e*b*radd0/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  tdd(6) = -(b*(raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/a/h/e)
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  td0(6) = -(b*(radd0*sf+(p+rad)*sfd0)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  ndd(6) = 0.D0
  nd(6) = 0.d0
  nd0(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DI_DI

!  Differentiation of kepler_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fd
!   with respect to varying inputs: m
!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DI_DI(ecc, m, md0, md, f, fd0, fd, fdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd0
  DOUBLE PRECISION, INTENT(OUT) :: fd
  DOUBLE PRECISION, INTENT(OUT) :: fdd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed0, kd0, dkd0
  DOUBLE PRECISION :: ed, kd, dkd
  DOUBLE PRECISION :: edd, kdd, dkdd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d0
  DOUBLE PRECISION :: arg2d
  DOUBLE PRECISION :: arg2dd
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  ed0 = md0
  e = m
  edd = 0.D0
  DO ii=1,nmax
    kdd = edd - ecc*(edd*COS(e)-ed*ed0*SIN(e))
    kd = ed - ecc*ed*COS(e) - md
    kd0 = ed0 - ecc*ed0*COS(e) - md0
    k = e - ecc*SIN(e) - m
    dkdd = ecc*(edd*SIN(e)+ed*ed0*COS(e))
    dkd = ecc*ed*SIN(e)
    dkd0 = ecc*ed0*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    edd = edd - ((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*dk**2-(kd*dk-k*dkd)*2*&
&     dk*dkd0)/(dk**2)**2
    ed = ed - (kd*dk-k*dkd)/dk**2
    ed0 = ed0 - (kd0*dk-k*dkd0)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1dd = result1*(edd*COS(e/2.0d0)-ed*ed0*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1d0 = result1*ed0*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2dd = -(result2*(edd*SIN(e/2.0d0)+ed*ed0*COS(e/2.0d0)/2.0d0)/2.0d0)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2d0 = -(result2*ed0*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fdd = (2.0d0*(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1&
&   **2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d0+2*arg2*&
&   arg2d0))/(arg1**2+arg2**2)**2
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  fd0 = 2.0d0*(arg1d0*arg2-arg2d0*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DI_DI

!  Differentiation of dot_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd res
!   with respect to varying inputs: u v ud vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DI_DI(n, u, ud0, ud, udd, v, vd0, vd, vdd, res, resd0, &
& resd, resdd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: udd(n), vdd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.D0
  resd0 = 0.D0
  DO i=1,n
    resdd = resdd + udd(i)*v(i) + ud(i)*vd0(i) + ud0(i)*vd(i) + u(i)*vdd&
&     (i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd0(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DI_DI

!  Differentiation of hfunalpha_da_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h hdd0 hd hdd hddd hd0
!   with respect to varying inputs: pdeltai m alpha
!  Differentiation of hfunalpha_da_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h hd hdd
!   with respect to varying inputs: pdeltai m alpha
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunalpha_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hd
!   with respect to varying inputs: alpha
!   RW status of diff variables: alpha:in hd:out
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfunalpha in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h
!   with respect to varying inputs: pdeltai m alpha deltai
!   RW status of diff variables: h:out pdeltai:in m:in alpha:in
!                deltai:in
!#######################################################################
!## Hamiltonian
SUBROUTINE HFUNALPHA_DA_DA_DI_DI(m, md1, md0, md, deltai, deltaid, &
& pdeltai, pdeltaid1, pdeltaid0, pdeltaid, alpha, alphad2, alphad1, &
& alphad0, alphad, pars, cont, h, hd1, hd0, hd0d, hd, hdd1, hdd0, hdd0d&
& , hdd, hddd0, hddd, hdddd)
  IMPLICIT NONE
!!!!!!!!!
!h = u(1)
!!!!!!!!!
  DOUBLE PRECISION, INTENT(IN) :: m, alpha, deltai(5), pdeltai(5), pars(&
& 11), cont
  DOUBLE PRECISION, INTENT(IN) :: md1, alphad2, pdeltaid1(5)
  DOUBLE PRECISION, INTENT(IN) :: md0, alphad1, pdeltaid0(5)
  DOUBLE PRECISION, INTENT(IN) :: alphad0
  DOUBLE PRECISION, INTENT(IN) :: md, alphad, deltaid(5), pdeltaid(5)
  DOUBLE PRECISION, INTENT(OUT) :: h
  DOUBLE PRECISION, INTENT(OUT) :: hd1
  DOUBLE PRECISION, INTENT(OUT) :: hd0
  DOUBLE PRECISION, INTENT(OUT) :: hd0d
  DOUBLE PRECISION, INTENT(OUT) :: hd
  DOUBLE PRECISION, INTENT(OUT) :: hdd1
  DOUBLE PRECISION, INTENT(OUT) :: hdd0
  DOUBLE PRECISION, INTENT(OUT) :: hdd0d
  DOUBLE PRECISION, INTENT(OUT) :: hdd
  DOUBLE PRECISION, INTENT(OUT) :: hddd0
  DOUBLE PRECISION, INTENT(OUT) :: hddd
  DOUBLE PRECISION, INTENT(OUT) :: hdddd
!local variables
  DOUBLE PRECISION :: mu, i(5), bsail(3), sdir(3)
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3)
  DOUBLE PRECISION :: fxd1(6), fyd1(6), fzd1(6), pigd2(3)
  DOUBLE PRECISION :: fxd0(6), fyd0(6), fzd0(6), pigd1(3)
  DOUBLE PRECISION :: fxd0d(6), fyd0d(6), fzd0d(6), pigd1d(3)
  DOUBLE PRECISION :: pigd0(3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3)
  DOUBLE PRECISION :: fxdd0(6), fydd0(6), fzdd0(6), pigdd1(3)
  DOUBLE PRECISION :: fxdd(6), fydd(6), fzdd(6), pigdd0(3)
  DOUBLE PRECISION :: fxddd(6), fyddd(6), fzddd(6), pigdd0d(3)
  DOUBLE PRECISION :: pigdd(3)
  DOUBLE PRECISION :: usail(3), u(3), nnorb, hsail, aaorb
  DOUBLE PRECISION :: usaild2(3), hsaild1
  DOUBLE PRECISION :: usaild1(3), hsaild0
  DOUBLE PRECISION :: usaild1d(3), hsaild0d
  DOUBLE PRECISION :: usaild0(3)
  DOUBLE PRECISION :: usaild0d0(3)
  DOUBLE PRECISION :: usaild0d(3)
  DOUBLE PRECISION :: usaild0dd(3)
  DOUBLE PRECISION :: usaild(3), hsaild
  DOUBLE PRECISION :: usaildd1(3), hsaildd1
  DOUBLE PRECISION :: usaildd0(3), hsaildd0
  DOUBLE PRECISION :: usaildd0d(3), hsaildd0d
  DOUBLE PRECISION :: usaildd(3), hsaildd
  DOUBLE PRECISION :: usailddd0(3), hsailddd0
  DOUBLE PRECISION :: usailddd(3), hsailddd
  DOUBLE PRECISION :: usaildddd(3), hsaildddd
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
! Gravitational constant
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Optical coefficients
  bsail = pars(9:11)
! Direction of the Sun
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
! GVEs
  CALL GVEECI_DA_DI_DI(m, md1, md0, md, i, mu, fx, fxd1, fxd0, fxd0d, &
&                fxd, fxdd0, fxdd, fxddd, fy, fyd1, fyd0, fyd0d, fyd, &
&                fydd0, fydd, fyddd, fz, fzd1, fzd0, fzd0d, fzd, fzdd0, &
&                fzdd, fzddd)
  CALL DOT_DA_DI_DI(5, pdeltai, pdeltaid1, pdeltaid0, pdeltaid, fx, fxd1&
&             , fxd0, fxd0d, fxd, fxdd0, fxdd, fxddd, pig(1), pigd2(1), &
&             pigd1(1), pigd1d(1), pigd(1), pigdd1(1), pigdd0(1), &
&             pigdd0d(1))
  CALL DOT_DA_DI_DI(5, pdeltai, pdeltaid1, pdeltaid0, pdeltaid, fy, fyd1&
&             , fyd0, fyd0d, fyd, fydd0, fydd, fyddd, pig(2), pigd2(2), &
&             pigd1(2), pigd1d(2), pigd(2), pigdd1(2), pigdd0(2), &
&             pigdd0d(2))
  CALL DOT_DA_DI_DI(5, pdeltai, pdeltaid1, pdeltaid0, pdeltaid, fz, fzd1&
&             , fzd0, fzd0d, fzd, fzdd0, fzdd, fzddd, pig(3), pigd2(3), &
&             pigd1(3), pigd1d(3), pigd(3), pigdd1(3), pigdd0(3), &
&             pigdd0d(3))
! Hamiltonian of the sail
  CALL PMPSAIL_DA_DA_DI_DI(pig, pigd2, pigd1, pigd1d, pigd, pigdd1, &
&                    pigdd0, pigdd0d, sdir, alpha, alphad2, alphad1, &
&                    alphad0, alphad, bsail, usail, usaild2, usaild1, &
&                    usaild1d, usaild0, usaild0d0, usaild0d, usaild0dd, &
&                    usaild, usaildd1, usaildd0, usaildd0d, usaildd, &
&                    usailddd0, usailddd, usaildddd)
  CALL DOT_DA_DA_DI_DI(3, pig, pigd2, pigd1, pigd1d, pigd, pigdd1, &
&                pigdd0, pigdd0d, usail, usaild2, usaild1, usaild1d, &
&                usaild0, usaild0d0, usaild0d, usaild0dd, usaild, &
&                usaildd1, usaildd0, usaildd0d, usaildd, usailddd0, &
&                usailddd, usaildddd, hsail, hsaild1, hsaild0, hsaild0d&
&                , hsaild, hsaildd1, hsaildd0, hsaildd0d, hsaildd, &
&                hsailddd0, hsailddd, hsaildddd)
  hdddd = hsaildddd
  hddd = hsailddd
  hddd0 = hsailddd0
  hdd = hsaildd
  hdd0d = hsaildd0d
  hdd0 = hsaildd0
  hdd1 = hsaildd1
  hd = hsaild
  hd0d = hsaild0d
  hd0 = hsaild0
  hd1 = hsaild1
  h = hsail
! Mean longitude as time variable
  aaorb = pars(5)
  arg1 = mu/aaorb**3
  nnorb = SQRT(arg1)
  hdddd = hdddd/nnorb
  hddd = hddd/nnorb
  hddd0 = hddd0/nnorb
  hdd = hdd/nnorb
  hdd0d = hdd0d/nnorb
  hdd0 = hdd0/nnorb
  hdd1 = hdd1/nnorb
  hd = hd/nnorb
  hd0d = hd0d/nnorb
  hd0 = hd0/nnorb
  hd1 = hd1/nnorb
  h = h/nnorb
END SUBROUTINE HFUNALPHA_DA_DA_DI_DI

!  Differentiation of gveeci_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fxdd fzd fyd0 fzdd fxd fxd0
!                fydd fzd0 fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fzd fxd fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DA_DI_DI(m, md1, md0, md, i, mu, fx, fxd1, fxd0, fxd0d&
& , fxd, fxdd0, fxdd, fxddd, fy, fyd1, fyd0, fyd0d, fyd, fydd0, fydd, &
& fyddd, fz, fzd1, fzd0, fzd0d, fzd, fzdd0, fzdd, fzddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md1
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd1(6), fyd1(6), fzd1(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0(6), fyd0(6), fzd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0d(6), fyd0d(6), fzd0d(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd0(6), fydd0(6), fzdd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd(6), fydd(6), fzdd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxddd(6), fyddd(6), fzddd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd1(6), td1(6), nd1(6), fd1, thetad1, sthd1, cthd1
  DOUBLE PRECISION :: rd0(6), td0(6), nd0(6), fd0, thetad0, sthd0, cthd0
  DOUBLE PRECISION :: rd0d(6), td0d(6), nd0d(6), fd0d, thetad0d, sthd0d&
& , cthd0d
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  DOUBLE PRECISION :: rdd0(6), tdd0(6), ndd0(6), fdd0, thetadd0, sthdd0&
& , cthdd0
  DOUBLE PRECISION :: rdd(6), tdd(6), ndd(6), fdd, thetadd, sthdd, cthdd
  DOUBLE PRECISION :: rddd(6), tddd(6), nddd(6), fddd, thetaddd, sthddd&
& , cthddd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DA_DI_DI(m, md1, md0, md, i, mu, r, rd1, rd0, rd0d, rd, &
&                 rdd0, rdd, rddd, t, td1, td0, td0d, td, tdd0, tdd, &
&                 tddd, n, nd1, nd0, nd0d, nd, ndd0, ndd, nddd, f, fd1, &
&                 fd0, fd0d, fd, fdd0, fdd, fddd)
  thetaddd = fddd
  thetadd = fdd
  thetadd0 = fdd0
  thetad = fd
  thetad0d = fd0d
  thetad0 = fd0
  thetad1 = fd1
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthddd = thetaddd*COS(theta) - thetadd*thetad1*SIN(theta) - (thetadd0*&
&   thetad0+thetad*thetad0d)*SIN(theta) - thetad*thetad0*thetad1*COS(&
&   theta)
  sthdd = thetadd*COS(theta) - thetad*thetad0*SIN(theta)
  sthdd0 = thetadd0*COS(theta) - thetad*thetad1*SIN(theta)
  sthd = thetad*COS(theta)
  sthd0d = thetad0d*COS(theta) - thetad0*thetad1*SIN(theta)
  sthd0 = thetad0*COS(theta)
  sthd1 = thetad1*COS(theta)
  sth = SIN(theta)
  cthddd = -(thetaddd*SIN(theta)+thetadd*thetad1*COS(theta)+(thetadd0*&
&   thetad0+thetad*thetad0d)*COS(theta)-thetad*thetad0*thetad1*SIN(theta&
&   ))
  cthdd = -(thetadd*SIN(theta)+thetad*thetad0*COS(theta))
  cthdd0 = -(thetadd0*SIN(theta)+thetad*thetad1*COS(theta))
  cthd = -(thetad*SIN(theta))
  cthd0d = -(thetad0d*SIN(theta)+thetad0*thetad1*COS(theta))
  cthd0 = -(thetad0*SIN(theta))
  cthd1 = -(thetad1*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxddd = rddd*(-(som*ci*sth)+com*cth) + rdd*(com*cthd1-som*ci*sthd1) + &
&   rdd0*(com*cthd0-som*ci*sthd0) + rd*(com*cthd0d-som*ci*sthd0d) + rd0d&
&   *(com*cthd-som*ci*sthd) + rd0*(com*cthdd0-som*ci*sthdd0) + rd1*(com*&
&   cthdd-som*ci*sthdd) + r*(com*cthddd-som*ci*sthddd) + tddd*(-(som*ci*&
&   cth)-com*sth) + tdd*(-(som*ci*cthd1)-com*sthd1) + tdd0*(-(som*ci*&
&   cthd0)-com*sthd0) + td*(-(som*ci*cthd0d)-com*sthd0d) + td0d*(-(som*&
&   ci*cthd)-com*sthd) + td0*(-(som*ci*cthdd0)-com*sthdd0) + td1*(-(som*&
&   ci*cthdd)-com*sthdd) + t*(-(som*ci*cthddd)-com*sthddd) + som*si*nddd
  fxdd = rdd*(-(som*ci*sth)+com*cth) + rd*(com*cthd0-som*ci*sthd0) + rd0&
&   *(com*cthd-som*ci*sthd) + r*(com*cthdd-som*ci*sthdd) + tdd*(-(som*ci&
&   *cth)-com*sth) + td*(-(som*ci*cthd0)-com*sthd0) + td0*(-(som*ci*cthd&
&   )-com*sthd) + t*(-(som*ci*cthdd)-com*sthdd) + som*si*ndd
  fxdd0 = rdd0*(-(som*ci*sth)+com*cth) + rd*(com*cthd1-som*ci*sthd1) + &
&   rd1*(com*cthd-som*ci*sthd) + r*(com*cthdd0-som*ci*sthdd0) + tdd0*(-(&
&   som*ci*cth)-com*sth) + td*(-(som*ci*cthd1)-com*sthd1) + td1*(-(som*&
&   ci*cthd)-com*sthd) + t*(-(som*ci*cthdd0)-com*sthdd0) + som*si*ndd0
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fxd0d = rd0d*(-(som*ci*sth)+com*cth) + rd0*(com*cthd1-som*ci*sthd1) + &
&   rd1*(com*cthd0-som*ci*sthd0) + r*(com*cthd0d-som*ci*sthd0d) + td0d*(&
&   -(som*ci*cth)-com*sth) + td0*(-(som*ci*cthd1)-com*sthd1) + td1*(-(&
&   som*ci*cthd0)-com*sthd0) + t*(-(som*ci*cthd0d)-com*sthd0d) + som*si*&
&   nd0d
  fxd0 = rd0*(-(som*ci*sth)+com*cth) + r*(com*cthd0-som*ci*sthd0) + td0*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd0)-com*sthd0) + som*si*nd0
  fxd1 = rd1*(-(som*ci*sth)+com*cth) + r*(com*cthd1-som*ci*sthd1) + td1*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd1)-com*sthd1) + som*si*nd1
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fyddd = rddd*(com*ci*sth+som*cth) + rdd*(com*ci*sthd1+som*cthd1) + &
&   rdd0*(com*ci*sthd0+som*cthd0) + rd*(com*ci*sthd0d+som*cthd0d) + rd0d&
&   *(com*ci*sthd+som*cthd) + rd0*(com*ci*sthdd0+som*cthdd0) + rd1*(com*&
&   ci*sthdd+som*cthdd) + r*(com*ci*sthddd+som*cthddd) + tddd*(com*ci*&
&   cth-som*sth) + tdd*(com*ci*cthd1-som*sthd1) + tdd0*(com*ci*cthd0-som&
&   *sthd0) + td*(com*ci*cthd0d-som*sthd0d) + td0d*(com*ci*cthd-som*sthd&
&   ) + td0*(com*ci*cthdd0-som*sthdd0) + td1*(com*ci*cthdd-som*sthdd) + &
&   t*(com*ci*cthddd-som*sthddd) - com*si*nddd
  fydd = rdd*(com*ci*sth+som*cth) + rd*(com*ci*sthd0+som*cthd0) + rd0*(&
&   com*ci*sthd+som*cthd) + r*(com*ci*sthdd+som*cthdd) + tdd*(com*ci*cth&
&   -som*sth) + td*(com*ci*cthd0-som*sthd0) + td0*(com*ci*cthd-som*sthd)&
&   + t*(com*ci*cthdd-som*sthdd) - com*si*ndd
  fydd0 = rdd0*(com*ci*sth+som*cth) + rd*(com*ci*sthd1+som*cthd1) + rd1*&
&   (com*ci*sthd+som*cthd) + r*(com*ci*sthdd0+som*cthdd0) + tdd0*(com*ci&
&   *cth-som*sth) + td*(com*ci*cthd1-som*sthd1) + td1*(com*ci*cthd-som*&
&   sthd) + t*(com*ci*cthdd0-som*sthdd0) - com*si*ndd0
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fyd0d = rd0d*(com*ci*sth+som*cth) + rd0*(com*ci*sthd1+som*cthd1) + rd1&
&   *(com*ci*sthd0+som*cthd0) + r*(com*ci*sthd0d+som*cthd0d) + td0d*(com&
&   *ci*cth-som*sth) + td0*(com*ci*cthd1-som*sthd1) + td1*(com*ci*cthd0-&
&   som*sthd0) + t*(com*ci*cthd0d-som*sthd0d) - com*si*nd0d
  fyd0 = rd0*(com*ci*sth+som*cth) + r*(com*ci*sthd0+som*cthd0) + td0*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd0-som*sthd0) - com*si*nd0
  fyd1 = rd1*(com*ci*sth+som*cth) + r*(com*ci*sthd1+som*cthd1) + td1*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd1-som*sthd1) - com*si*nd1
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzddd = si*(rddd*sth+rdd*sthd1+rdd0*sthd0+rd*sthd0d+rd0d*sthd+rd0*&
&   sthdd0+rd1*sthdd+r*sthddd) + si*(tddd*cth+tdd*cthd1+tdd0*cthd0+td*&
&   cthd0d+td0d*cthd+td0*cthdd0+td1*cthdd+t*cthddd) + ci*nddd
  fzdd = si*(rdd*sth+rd*sthd0+rd0*sthd+r*sthdd) + si*(tdd*cth+td*cthd0+&
&   td0*cthd+t*cthdd) + ci*ndd
  fzdd0 = si*(rdd0*sth+rd*sthd1+rd1*sthd+r*sthdd0) + si*(tdd0*cth+td*&
&   cthd1+td1*cthd+t*cthdd0) + ci*ndd0
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fzd0d = si*(rd0d*sth+rd0*sthd1+rd1*sthd0+r*sthd0d) + si*(td0d*cth+td0*&
&   cthd1+td1*cthd0+t*cthd0d) + ci*nd0d
  fzd0 = si*(rd0*sth+r*sthd0) + si*(td0*cth+t*cthd0) + ci*nd0
  fzd1 = si*(rd1*sth+r*sthd1) + si*(td1*cth+t*cthd1) + ci*nd1
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DA_DI_DI

!  Differentiation of gvelvlh_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f rd0 ndd nd n r t fdd td0
!                rd rdd nd0 fd fd0 tdd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f nd n r t rd fd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DA_DI_DI(m, md1, md0, md, i, mu, r, rd1, rd0, rd0d, &
& rd, rdd0, rdd, rddd, t, td1, td0, td0d, td, tdd0, tdd, tddd, n, nd1, &
& nd0, nd0d, nd, ndd0, ndd, nddd, f, fd1, fd0, fd0d, fd, fdd0, fdd, fddd&
&)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md1
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd1(6), td1(6), nd1(6), fd1
  DOUBLE PRECISION, INTENT(OUT) :: rd0(6), td0(6), nd0(6), fd0
  DOUBLE PRECISION, INTENT(OUT) :: rd0d(6), td0d(6), nd0d(6), fd0d
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
  DOUBLE PRECISION, INTENT(OUT) :: rdd0(6), tdd0(6), ndd0(6), fdd0
  DOUBLE PRECISION, INTENT(OUT) :: rdd(6), tdd(6), ndd(6), fdd
  DOUBLE PRECISION, INTENT(OUT) :: rddd(6), tddd(6), nddd(6), fddd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd1, sfd1, radd1, thetad1
  DOUBLE PRECISION :: cfd0, sfd0, radd0, thetad0
  DOUBLE PRECISION :: cfd0d, sfd0d, radd0d, thetad0d
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  DOUBLE PRECISION :: cfdd0, sfdd0, raddd0, thetadd0
  DOUBLE PRECISION :: cfdd, sfdd, raddd, thetadd
  DOUBLE PRECISION :: cfddd, sfddd, radddd, thetaddd
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DA_DI_DI(e, m, md1, md0, md, f, fd1, fd0, fd0d, fd, fdd0, &
&                fdd, fddd)
! Useful variables
  cfddd = -(fddd*SIN(f)+fdd*fd1*COS(f)+(fdd0*fd0+fd*fd0d)*COS(f)-fd*fd0*&
&   fd1*SIN(f))
  cfdd = -(fdd*SIN(f)+fd*fd0*COS(f))
  cfdd0 = -(fdd0*SIN(f)+fd*fd1*COS(f))
  cfd = -(fd*SIN(f))
  cfd0d = -(fd0d*SIN(f)+fd0*fd1*COS(f))
  cfd0 = -(fd0*SIN(f))
  cfd1 = -(fd1*SIN(f))
  cf = COS(f)
  sfddd = fddd*COS(f) - fdd*fd1*SIN(f) - (fdd0*fd0+fd*fd0d)*SIN(f) - fd*&
&   fd0*fd1*COS(f)
  sfdd = fdd*COS(f) - fd*fd0*SIN(f)
  sfdd0 = fdd0*COS(f) - fd*fd1*SIN(f)
  sfd = fd*COS(f)
  sfd0d = fd0d*COS(f) - fd0*fd1*SIN(f)
  sfd0 = fd0*COS(f)
  sfd1 = fd1*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  radddd = -(((p*e*(cfddd*(1.0d0+e*cf)**2+cfdd*2*(1.0d0+e*cf)*e*cfd1)-p*&
&   e**2*2*((cfdd0*cfd0+cfd*cfd0d)*(1.0d0+e*cf)+cfd*cfd0*e*cfd1))*(1.0d0&
&   +e*cf)**4-(p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)*&
&   2**2*(1.0d0+e*cf)**3*e*cfd1)/(((1.0d0+e*cf)**2)**2)**2)
  raddd = -((p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)/((&
&   1.0d0+e*cf)**2)**2)
  raddd0 = -((p*e*cfdd0*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd1)/&
&   ((1.0d0+e*cf)**2)**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  radd0d = -((p*e*cfd0d*(1.0d0+e*cf)**2-p*e**2*cfd0*2*(1.0d0+e*cf)*cfd1)&
&   /((1.0d0+e*cf)**2)**2)
  radd0 = -(p*e*cfd0/(1.0d0+e*cf)**2)
  radd1 = -(p*e*cfd1/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetaddd = fddd
  thetadd = fdd
  thetadd0 = fdd0
  thetad = fd
  thetad0d = fd0d
  thetad0 = fd0
  thetad1 = fd1
  theta = w + f
! GVEs
  rd(1) = 0.d0
  rd0(1) = 0.d0
  rd1(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.d0
  td0(1) = 0.d0
  td1(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.d0
  ndd = 0.d0
  nddd = 0.D0
  nddd(1) = (radddd*SIN(theta)+raddd*thetad1*COS(theta)+(raddd0*thetad0+&
&   radd*thetad0d)*COS(theta)-radd*thetad0*thetad1*SIN(theta)+(radd0d*&
&   thetad+radd0*thetadd0+radd1*thetadd+rad*thetaddd)*COS(theta)-(radd0*&
&   thetad+rad*thetadd)*thetad1*SIN(theta)-((radd1*thetad+rad*thetadd0)*&
&   thetad0+rad*thetad*thetad0d)*SIN(theta)-rad*thetad*thetad0*thetad1*&
&   COS(theta))/h/SIN(inc)
  ndd(1) = (raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*thetad+rad*&
&   thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(inc)
  ndd0 = 0.D0
  ndd0(1) = (raddd0*SIN(theta)+radd*thetad1*COS(theta)+(radd1*thetad+rad&
&   *thetadd0)*COS(theta)-rad*thetad*thetad1*SIN(theta))/h/SIN(inc)
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  nd0 = 0.d0
  nd0d = 0.D0
  nd0d(1) = (radd0d*SIN(theta)+radd0*thetad1*COS(theta)+(radd1*thetad0+&
&   rad*thetad0d)*COS(theta)-rad*thetad0*thetad1*SIN(theta))/h/SIN(inc)
  nd0(1) = (radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(inc)
  nd1 = 0.D0
  nd1(1) = (radd1*SIN(theta)+rad*thetad1*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.d0
  rd0(2) = 0.d0
  rd1(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.d0
  td0(2) = 0.d0
  td1(2) = 0.D0
  t(2) = 0.0d0
  nddd(2) = (radddd*COS(theta)-raddd*thetad1*SIN(theta)-(raddd0*thetad0+&
&   radd*thetad0d)*SIN(theta)-radd*thetad0*thetad1*COS(theta)-(radd0d*&
&   thetad+radd0*thetadd0+radd1*thetadd+rad*thetaddd)*SIN(theta)-(radd0*&
&   thetad+rad*thetadd)*thetad1*COS(theta)-((radd1*thetad+rad*thetadd0)*&
&   thetad0+rad*thetad*thetad0d)*COS(theta)+rad*thetad*thetad0*thetad1*&
&   SIN(theta))/h
  ndd(2) = (raddd*COS(theta)-radd*thetad0*SIN(theta)-(radd0*thetad+rad*&
&   thetadd)*SIN(theta)-rad*thetad*thetad0*COS(theta))/h
  ndd0(2) = (raddd0*COS(theta)-radd*thetad1*SIN(theta)-(radd1*thetad+rad&
&   *thetadd0)*SIN(theta)-rad*thetad*thetad1*COS(theta))/h
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  nd0d(2) = (radd0d*COS(theta)-radd0*thetad1*SIN(theta)-(radd1*thetad0+&
&   rad*thetad0d)*SIN(theta)-rad*thetad0*thetad1*COS(theta))/h
  nd0(2) = (radd0*COS(theta)-rad*thetad0*SIN(theta))/h
  nd1(2) = (radd1*COS(theta)-rad*thetad1*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.d0
  rdd = 0.d0
  rddd = 0.D0
  rddd(3) = -(p*cfddd/h/e)
  rdd(3) = -(p*cfdd/h/e)
  rdd0 = 0.D0
  rdd0(3) = -(p*cfdd0/h/e)
  rd(3) = -(p*cfd/h/e)
  rd0 = 0.d0
  rd0d = 0.D0
  rd0d(3) = -(p*cfd0d/h/e)
  rd0(3) = -(p*cfd0/h/e)
  rd1 = 0.D0
  rd1(3) = -(p*cfd1/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.d0
  tdd = 0.d0
  tddd = 0.D0
  tddd(3) = (radddd*sf+raddd*sfd1+raddd0*sfd0+radd*sfd0d+radd0d*sfd+&
&   radd0*sfdd0+radd1*sfdd+(p+rad)*sfddd)/h/e
  tdd(3) = (raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/h/e
  tdd0 = 0.D0
  tdd0(3) = (raddd0*sf+radd*sfd1+radd1*sfd+(p+rad)*sfdd0)/h/e
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  td0 = 0.d0
  td0d = 0.D0
  td0d(3) = (radd0d*sf+radd0*sfd1+radd1*sfd0+(p+rad)*sfd0d)/h/e
  td0(3) = (radd0*sf+(p+rad)*sfd0)/h/e
  td1 = 0.D0
  td1(3) = (radd1*sf+(p+rad)*sfd1)/h/e
  t(3) = (p+rad)*sf/h/e
  nddd(3) = -(COS(inc)*(radddd*SIN(theta)+raddd*thetad1*COS(theta)+(&
&   raddd0*thetad0+radd*thetad0d)*COS(theta)-radd*thetad0*thetad1*SIN(&
&   theta)+(radd0d*thetad+radd0*thetadd0+radd1*thetadd+rad*thetaddd)*COS&
&   (theta)-(radd0*thetad+rad*thetadd)*thetad1*SIN(theta)-((radd1*thetad&
&   +rad*thetadd0)*thetad0+rad*thetad*thetad0d)*SIN(theta)-rad*thetad*&
&   thetad0*thetad1*COS(theta))/h/SIN(inc))
  ndd(3) = -(COS(inc)*(raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*&
&   thetad+rad*thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(&
&   inc))
  ndd0(3) = -(COS(inc)*(raddd0*SIN(theta)+radd*thetad1*COS(theta)+(radd1&
&   *thetad+rad*thetadd0)*COS(theta)-rad*thetad*thetad1*SIN(theta))/h/&
&   SIN(inc))
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  nd0d(3) = -(COS(inc)*(radd0d*SIN(theta)+radd0*thetad1*COS(theta)+(&
&   radd1*thetad0+rad*thetad0d)*COS(theta)-rad*thetad0*thetad1*SIN(theta&
&   ))/h/SIN(inc))
  nd0(3) = -(COS(inc)*(radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(&
&   inc))
  nd1(3) = -(COS(inc)*(radd1*SIN(theta)+rad*thetad1*COS(theta))/h/SIN(&
&   inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rddd(4) = 2.0d0*a**2*e*sfddd/h
  rdd(4) = 2.0d0*a**2*e*sfdd/h
  rdd0(4) = 2.0d0*a**2*e*sfdd0/h
  rd(4) = 2.0d0*a**2*e*sfd/h
  rd0d(4) = 2.0d0*a**2*e*sfd0d/h
  rd0(4) = 2.0d0*a**2*e*sfd0/h
  rd1(4) = 2.0d0*a**2*e*sfd1/h
  r(4) = 2.0d0*a**2*e*sf/h
  tddd(4) = -(((2.0d0*a**2*p*(radddd*rad**2+raddd*2*rad*radd1)/h-2.0d0*a&
&   **2*p*2*((raddd0*rad+radd*radd1)*radd0+radd*rad*radd0d)/h)*rad**4-(&
&   2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/h)*2**2*&
&   rad**3*radd1)/((rad**2)**2)**2)
  tdd(4) = -((2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/&
&   h)/(rad**2)**2)
  tdd0(4) = -((2.0d0*a**2*p*raddd0*rad**2/h-2.0d0*a**2*p*radd*2*rad*&
&   radd1/h)/(rad**2)**2)
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  td0d(4) = -((2.0d0*a**2*p*radd0d*rad**2/h-2.0d0*a**2*p*radd0*2*rad*&
&   radd1/h)/(rad**2)**2)
  td0(4) = -(2.0d0*a**2*p*radd0/h/rad**2)
  td1(4) = -(2.0d0*a**2*p*radd1/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  nddd(4) = 0.D0
  ndd(4) = 0.d0
  ndd0(4) = 0.D0
  nd(4) = 0.d0
  nd0d(4) = 0.D0
  nd0(4) = 0.d0
  nd1(4) = 0.D0
  n(4) = 0.0d0
  rddd(5) = p*sfddd/h
  rdd(5) = p*sfdd/h
  rdd0(5) = p*sfdd0/h
  rd(5) = p*sfd/h
  rd0d(5) = p*sfd0d/h
  rd0(5) = p*sfd0/h
  rd1(5) = p*sfd1/h
  r(5) = p*sf/h
  tddd(5) = (radddd*cf+raddd*cfd1+raddd0*cfd0+radd*cfd0d+radd0d*cfd+&
&   radd0*cfdd0+radd1*cfdd+(p+rad)*cfddd+e*radddd)/h
  tdd(5) = (raddd*cf+radd*cfd0+radd0*cfd+(p+rad)*cfdd+e*raddd)/h
  tdd0(5) = (raddd0*cf+radd*cfd1+radd1*cfd+(p+rad)*cfdd0+e*raddd0)/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  td0d(5) = (radd0d*cf+radd0*cfd1+radd1*cfd0+(p+rad)*cfd0d+e*radd0d)/h
  td0(5) = (radd0*cf+(p+rad)*cfd0+e*radd0)/h
  td1(5) = (radd1*cf+(p+rad)*cfd1+e*radd1)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  nddd(5) = 0.D0
  ndd(5) = 0.d0
  ndd0(5) = 0.D0
  nd(5) = 0.d0
  nd0d(5) = 0.D0
  nd0(5) = 0.d0
  nd1(5) = 0.D0
  n(5) = 0.0d0
  rddd(6) = p*cfddd - 2.0d0*e*b*radddd/a/h/e
  rdd(6) = p*cfdd - 2.0d0*e*b*raddd/a/h/e
  rdd0(6) = p*cfdd0 - 2.0d0*e*b*raddd0/a/h/e
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  rd0d(6) = p*cfd0d - 2.0d0*e*b*radd0d/a/h/e
  rd0(6) = p*cfd0 - 2.0d0*e*b*radd0/a/h/e
  rd1(6) = p*cfd1 - 2.0d0*e*b*radd1/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  tddd(6) = -(b*(radddd*sf+raddd*sfd1+raddd0*sfd0+radd*sfd0d+radd0d*sfd+&
&   radd0*sfdd0+radd1*sfdd+(p+rad)*sfddd)/a/h/e)
  tdd(6) = -(b*(raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/a/h/e)
  tdd0(6) = -(b*(raddd0*sf+radd*sfd1+radd1*sfd+(p+rad)*sfdd0)/a/h/e)
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  td0d(6) = -(b*(radd0d*sf+radd0*sfd1+radd1*sfd0+(p+rad)*sfd0d)/a/h/e)
  td0(6) = -(b*(radd0*sf+(p+rad)*sfd0)/a/h/e)
  td1(6) = -(b*(radd1*sf+(p+rad)*sfd1)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  nddd(6) = 0.D0
  ndd(6) = 0.d0
  ndd0(6) = 0.D0
  nd(6) = 0.d0
  nd0d(6) = 0.D0
  nd0(6) = 0.d0
  nd1(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DA_DI_DI

!  Differentiation of kepler_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fdd fd fd0
!   with respect to varying inputs: m
!  Differentiation of kepler_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fd
!   with respect to varying inputs: m
!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DA_DI_DI(ecc, m, md1, md0, md, f, fd1, fd0, fd0d, fd, &
& fdd0, fdd, fddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md1
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd1
  DOUBLE PRECISION, INTENT(OUT) :: fd0
  DOUBLE PRECISION, INTENT(OUT) :: fd0d
  DOUBLE PRECISION, INTENT(OUT) :: fd
  DOUBLE PRECISION, INTENT(OUT) :: fdd0
  DOUBLE PRECISION, INTENT(OUT) :: fdd
  DOUBLE PRECISION, INTENT(OUT) :: fddd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed1, kd1, dkd1
  DOUBLE PRECISION :: ed0, kd0, dkd0
  DOUBLE PRECISION :: ed0d, kd0d, dkd0d
  DOUBLE PRECISION :: ed, kd, dkd
  DOUBLE PRECISION :: edd0, kdd0, dkdd0
  DOUBLE PRECISION :: edd, kdd, dkdd
  DOUBLE PRECISION :: eddd, kddd, dkddd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d0d
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd0
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: arg1ddd
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d1
  DOUBLE PRECISION :: arg2d0
  DOUBLE PRECISION :: arg2d0d
  DOUBLE PRECISION :: arg2d
  DOUBLE PRECISION :: arg2dd0
  DOUBLE PRECISION :: arg2dd
  DOUBLE PRECISION :: arg2ddd
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  ed0 = md0
  ed1 = md1
  e = m
  edd = 0.d0
  ed0d = 0.D0
  edd0 = 0.D0
  eddd = 0.D0
  DO ii=1,nmax
    kddd = eddd - ecc*(eddd*COS(e)-edd*ed1*SIN(e)-(edd0*ed0+ed*ed0d)*SIN&
&     (e)-ed*ed0*ed1*COS(e))
    kdd = edd - ecc*(edd*COS(e)-ed*ed0*SIN(e))
    kdd0 = edd0 - ecc*(edd0*COS(e)-ed*ed1*SIN(e))
    kd = ed - ecc*ed*COS(e) - md
    kd0d = ed0d - ecc*(ed0d*COS(e)-ed0*ed1*SIN(e))
    kd0 = ed0 - ecc*ed0*COS(e) - md0
    kd1 = ed1 - ecc*ed1*COS(e) - md1
    k = e - ecc*SIN(e) - m
    dkddd = ecc*(eddd*SIN(e)+edd*ed1*COS(e)+(edd0*ed0+ed*ed0d)*COS(e)-ed&
&     *ed0*ed1*SIN(e))
    dkdd = ecc*(edd*SIN(e)+ed*ed0*COS(e))
    dkdd0 = ecc*(edd0*SIN(e)+ed*ed1*COS(e))
    dkd = ecc*ed*SIN(e)
    dkd0d = ecc*(ed0d*SIN(e)+ed0*ed1*COS(e))
    dkd0 = ecc*ed0*SIN(e)
    dkd1 = ecc*ed1*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    eddd = eddd - (((kddd*dk+kdd*dkd1+kdd0*dkd0+kd*dkd0d-kd0d*dkd-kd0*&
&     dkdd0-kd1*dkdd-k*dkddd)*dk**2+(kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*2*dk&
&     *dkd1-2*((kdd0*dk+kd*dkd1-kd1*dkd-k*dkdd0)*dk*dkd0)-2*((kd*dk-k*&
&     dkd)*(dkd1*dkd0+dk*dkd0d)))*dk**4-((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)&
&     *dk**2-(kd*dk-k*dkd)*2*dk*dkd0)*2**2*dk**3*dkd1)/((dk**2)**2)**2
    edd = edd - ((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*dk**2-(kd*dk-k*dkd)*2*&
&     dk*dkd0)/(dk**2)**2
    edd0 = edd0 - ((kdd0*dk+kd*dkd1-kd1*dkd-k*dkdd0)*dk**2-(kd*dk-k*dkd)&
&     *2*dk*dkd1)/(dk**2)**2
    ed = ed - (kd*dk-k*dkd)/dk**2
    ed0d = ed0d - ((kd0d*dk+kd0*dkd1-kd1*dkd0-k*dkd0d)*dk**2-(kd0*dk-k*&
&     dkd0)*2*dk*dkd1)/(dk**2)**2
    ed0 = ed0 - (kd0*dk-k*dkd0)/dk**2
    ed1 = ed1 - (kd1*dk-k*dkd1)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1ddd = result1*(eddd*COS(e/2.0d0)-edd*ed1*SIN(e/2.0d0)/2.0d0-((edd0&
&   *ed0+ed*ed0d)*SIN(e/2.0d0)+ed*ed0*ed1*COS(e/2.0d0)/2.0d0)/2.0d0)/&
&   2.0d0
  arg1dd = result1*(edd*COS(e/2.0d0)-ed*ed0*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1dd0 = result1*(edd0*COS(e/2.0d0)-ed*ed1*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1d0d = result1*(ed0d*COS(e/2.0d0)-ed0*ed1*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d0 = result1*ed0*COS(e/2.0d0)/2.0d0
  arg1d1 = result1*ed1*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2ddd = -(result2*(eddd*SIN(e/2.0d0)+edd*ed1*COS(e/2.0d0)/2.0d0+((&
&   edd0*ed0+ed*ed0d)*COS(e/2.0d0)-ed*ed0*ed1*SIN(e/2.0d0)/2.0d0)/2.0d0)&
&   /2.0d0)
  arg2dd = -(result2*(edd*SIN(e/2.0d0)+ed*ed0*COS(e/2.0d0)/2.0d0)/2.0d0)
  arg2dd0 = -(result2*(edd0*SIN(e/2.0d0)+ed*ed1*COS(e/2.0d0)/2.0d0)/&
&   2.0d0)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2d0d = -(result2*(ed0d*SIN(e/2.0d0)+ed0*ed1*COS(e/2.0d0)/2.0d0)/&
&   2.0d0)
  arg2d0 = -(result2*ed0*SIN(e/2.0d0)/2.0d0)
  arg2d1 = -(result2*ed1*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fddd = ((2.0d0*((arg1ddd*arg2+arg1dd*arg2d1+arg1dd0*arg2d0+arg1d*&
&   arg2d0d-arg2ddd*arg1-arg2dd*arg1d1-arg2dd0*arg1d0-arg2d*arg1d0d)*(&
&   arg1**2+arg2**2)+(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)&
&   *(2*arg1*arg1d1+2*arg2*arg2d1))-2.0d0*((arg1dd0*arg2+arg1d*arg2d1-&
&   arg2dd0*arg1-arg2d*arg1d1)*(2*arg1*arg1d0+2*arg2*arg2d0)+(arg1d*arg2&
&   -arg2d*arg1)*(2*(arg1d1*arg1d0)+2*(arg1*arg1d0d)+2*(arg2d1*arg2d0)+2&
&   *(arg2*arg2d0d))))*(arg1**2+arg2**2)**2-(2.0d0*(arg1dd*arg2+arg1d*&
&   arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1**2+arg2**2)-2.0d0*(arg1d*arg2&
&   -arg2d*arg1)*(2*arg1*arg1d0+2*arg2*arg2d0))*2*(arg1**2+arg2**2)*(2*&
&   arg1*arg1d1+2*arg2*arg2d1))/((arg1**2+arg2**2)**2)**2
  fdd = (2.0d0*(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1&
&   **2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d0+2*arg2*&
&   arg2d0))/(arg1**2+arg2**2)**2
  fdd0 = (2.0d0*(arg1dd0*arg2+arg1d*arg2d1-arg2dd0*arg1-arg2d*arg1d1)*(&
&   arg1**2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d1+2*arg2&
&   *arg2d1))/(arg1**2+arg2**2)**2
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  fd0d = (2.0d0*(arg1d0d*arg2+arg1d0*arg2d1-arg2d0d*arg1-arg2d0*arg1d1)*&
&   (arg1**2+arg2**2)-2.0d0*(arg1d0*arg2-arg2d0*arg1)*(2*arg1*arg1d1+2*&
&   arg2*arg2d1))/(arg1**2+arg2**2)**2
  fd0 = 2.0d0*(arg1d0*arg2-arg2d0*arg1)/(arg1**2+arg2**2)
  fd1 = 2.0d0*(arg1d1*arg2-arg2d1*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DA_DI_DI

!  Differentiation of dot_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resdd resd res resd0
!   with respect to varying inputs: u v vd0 vd vdd
!  Differentiation of dot_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd res
!   with respect to varying inputs: u v vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DA_DI_DI(n, u, ud1, ud0, ud, v, vd1, vd0, vd0d, vd, vdd0&
& , vdd, vddd, res, resd1, resd0, resd0d, resd, resdd0, resdd, resddd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud1(n), vd1(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0d(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: vdd0(n)
  DOUBLE PRECISION, INTENT(IN) :: vdd(n)
  DOUBLE PRECISION, INTENT(IN) :: vddd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd1
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd0d
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd0
  DOUBLE PRECISION, INTENT(OUT) :: resdd
  DOUBLE PRECISION, INTENT(OUT) :: resddd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.d0
  resd0 = 0.d0
  resddd = 0.D0
  resdd0 = 0.D0
  resd1 = 0.D0
  resd0d = 0.D0
  DO i=1,n
    resddd = resddd + ud(i)*vd0d(i) + ud0(i)*vdd0(i) + ud1(i)*vdd(i) + u&
&     (i)*vddd(i)
    resdd = resdd + ud(i)*vd0(i) + ud0(i)*vd(i) + u(i)*vdd(i)
    resdd0 = resdd0 + ud(i)*vd1(i) + ud1(i)*vd(i) + u(i)*vdd0(i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0d = resd0d + ud0(i)*vd1(i) + ud1(i)*vd0(i) + u(i)*vd0d(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd0(i)
    resd1 = resd1 + ud1(i)*v(i) + u(i)*vd1(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DA_DI_DI

!  Differentiation of pmpsail_da_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud ud0d udd uddd ud0 ud1
!                udd0
!   with respect to varying inputs: alpha pigd0 pigdd pigd pig
!  Differentiation of pmpsail_da_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud udd ud0
!   with respect to varying inputs: alpha pigd pig
!  Differentiation of pmpsail_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud
!   with respect to varying inputs: alpha
!  Differentiation of pmpsail in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: alpha pig
!#######################################################################
!# PMP of the sail
SUBROUTINE PMPSAIL_DA_DA_DI_DI(pig, pigd1, pigd0, pigd0d, pigd, pigdd0, &
& pigdd, pigddd, sdir, alpha, alphad2, alphad1, alphad0, alphad, b, u, &
& ud2, ud1, ud1d, ud0, ud0d0, ud0d, ud0dd, ud, udd1, udd0, udd0d, udd, &
& uddd0, uddd, udddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), alpha, sdir(3), b(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd1(3), alphad2
  DOUBLE PRECISION, INTENT(IN) :: pigd0(3), alphad1
  DOUBLE PRECISION, INTENT(IN) :: pigd0d(3)
  DOUBLE PRECISION, INTENT(IN) :: alphad0
  DOUBLE PRECISION, INTENT(IN) :: pigd(3), alphad
  DOUBLE PRECISION, INTENT(IN) :: pigdd0(3)
  DOUBLE PRECISION, INTENT(IN) :: pigdd(3)
  DOUBLE PRECISION, INTENT(IN) :: pigddd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud2(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud1(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud1d(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0d0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0d(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0dd(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd1(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd0(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd0d(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd(3)
  DOUBLE PRECISION, INTENT(OUT) :: uddd0(3)
  DOUBLE PRECISION, INTENT(OUT) :: uddd(3)
  DOUBLE PRECISION, INTENT(OUT) :: udddd(3)
! local variables
  DOUBLE PRECISION :: b1, b2, b3, pis, pinorm, theta, kpolar, sperp(3), &
& calpha, salpha, fs, fperp
  DOUBLE PRECISION :: pisd1, sperpd1(3), calphad2, salphad2, fsd2, &
& fperpd2
  DOUBLE PRECISION :: pisd0, sperpd0(3), calphad1, salphad1, fsd1, &
& fperpd1
  DOUBLE PRECISION :: pisd0d, sperpd0d(3), calphad1d, salphad1d, fsd1d, &
& fperpd1d
  DOUBLE PRECISION :: calphad0, salphad0, fsd0, fperpd0
  DOUBLE PRECISION :: calphad0d0, salphad0d0, fsd0d0, fperpd0d0
  DOUBLE PRECISION :: calphad0d, salphad0d, fsd0d, fperpd0d
  DOUBLE PRECISION :: calphad0dd, salphad0dd, fsd0dd, fperpd0dd
  DOUBLE PRECISION :: pisd, sperpd(3), calphad, salphad, fsd, fperpd
  DOUBLE PRECISION :: pisdd0, sperpdd0(3), calphadd1, salphadd1, fsdd1, &
& fperpdd1
  DOUBLE PRECISION :: pisdd, sperpdd(3), calphadd0, salphadd0, fsdd0, &
& fperpdd0
  DOUBLE PRECISION :: pisddd, sperpddd(3), calphadd0d, salphadd0d, &
& fsdd0d, fperpdd0d
  DOUBLE PRECISION :: calphadd, salphadd, fsdd, fperpdd
  DOUBLE PRECISION :: calphaddd0, salphaddd0, fsddd0, fperpddd0
  DOUBLE PRECISION :: calphaddd, salphaddd, fsddd, fperpddd
  DOUBLE PRECISION :: calphadddd, salphadddd, fsdddd, fperpdddd
  INTRINSIC SQRT
  INTRINSIC ACOS
  INTRINSIC COS
  INTRINSIC SIN
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d0d
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd0
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: arg1ddd
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d1
  DOUBLE PRECISION :: result1d0
  DOUBLE PRECISION :: result1d0d
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result1dd0
  DOUBLE PRECISION :: result1dd
  DOUBLE PRECISION :: result1ddd
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d0
  DOUBLE PRECISION :: result10d
  DOUBLE PRECISION :: result10dd
  DOUBLE PRECISION :: result11
  DOUBLE PRECISION :: result11d
  b1 = b(1)
  b2 = b(2)
  b3 = b(3)
  pisddd = sdir(1)*pigddd(1) + sdir(2)*pigddd(2) + sdir(3)*pigddd(3)
  pisdd = sdir(1)*pigdd(1) + sdir(2)*pigdd(2) + sdir(3)*pigdd(3)
  pisdd0 = sdir(1)*pigdd0(1) + sdir(2)*pigdd0(2) + sdir(3)*pigdd0(3)
  pisd = sdir(1)*pigd(1) + sdir(2)*pigd(2) + sdir(3)*pigd(3)
  pisd0d = sdir(1)*pigd0d(1) + sdir(2)*pigd0d(2) + sdir(3)*pigd0d(3)
  pisd0 = sdir(1)*pigd0(1) + sdir(2)*pigd0(2) + sdir(3)*pigd0(3)
  pisd1 = sdir(1)*pigd1(1) + sdir(2)*pigd1(2) + sdir(3)*pigd1(3)
  pis = pig(1)*sdir(1) + pig(2)*sdir(2) + pig(3)*sdir(3)
  arg1 = pig(1)**2 + pig(2)**2 + pig(3)**2
  pinorm = SQRT(arg1)
  theta = ACOS(pis/pinorm)
! Definition of the unit vector sPerp
  sperpddd = pigddd - sdir*pisddd
  sperpdd = pigdd - sdir*pisdd
  sperpdd0 = pigdd0 - sdir*pisdd0
  sperpd = pigd - sdir*pisd
  sperpd0d = pigd0d - sdir*pisd0d
  sperpd0 = pigd0 - sdir*pisd0
  sperpd1 = pigd1 - sdir*pisd1
  sperp = pig - pis*sdir
! Note: nan for collinear vectors
  arg1ddd = 2*(sperpd0d(1)*sperpd(1)) + 2*(sperpd0(1)*sperpdd0(1)) + 2*(&
&   sperpd1(1)*sperpdd(1)) + 2*(sperp(1)*sperpddd(1)) + 2*(sperpd0d(2)*&
&   sperpd(2)) + 2*(sperpd0(2)*sperpdd0(2)) + 2*(sperpd1(2)*sperpdd(2)) &
&   + 2*(sperp(2)*sperpddd(2)) + 2*(sperpd0d(3)*sperpd(3)) + 2*(sperpd0(&
&   3)*sperpdd0(3)) + 2*(sperpd1(3)*sperpdd(3)) + 2*(sperp(3)*sperpddd(3&
&   ))
  arg1dd = 2*(sperpd0(1)*sperpd(1)) + 2*(sperp(1)*sperpdd(1)) + 2*(&
&   sperpd0(2)*sperpd(2)) + 2*(sperp(2)*sperpdd(2)) + 2*(sperpd0(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd(3))
  arg1dd0 = 2*(sperpd1(1)*sperpd(1)) + 2*(sperp(1)*sperpdd0(1)) + 2*(&
&   sperpd1(2)*sperpd(2)) + 2*(sperp(2)*sperpdd0(2)) + 2*(sperpd1(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd0(3))
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1d0d = 2*(sperpd1(1)*sperpd0(1)) + 2*(sperp(1)*sperpd0d(1)) + 2*(&
&   sperpd1(2)*sperpd0(2)) + 2*(sperp(2)*sperpd0d(2)) + 2*(sperpd1(3)*&
&   sperpd0(3)) + 2*(sperp(3)*sperpd0d(3))
  arg1d0 = 2*sperp(1)*sperpd0(1) + 2*sperp(2)*sperpd0(2) + 2*sperp(3)*&
&   sperpd0(3)
  arg1d1 = 2*sperp(1)*sperpd1(1) + 2*sperp(2)*sperpd1(2) + 2*sperp(3)*&
&   sperpd1(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
    result1dd = 0.d0
    result1ddd = 0.D0
    result1dd0 = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.d0
      result10dd = 0.D0
    ELSE
      IF (arg1 .EQ. 0.0) THEN
        result11d = 0.D0
      ELSE
        result11d = arg1d1/(2.0*SQRT(arg1))
      END IF
      result11 = SQRT(arg1)
      result10dd = (arg1d0d*2.0*result11-arg1d0*2.0*result11d)/(2.0*&
&       result11)**2
      result10d = arg1d0/(2.0*result11)
    END IF
    IF (arg1 .EQ. 0.0) THEN
      result10d0 = 0.D0
    ELSE
      result10d0 = arg1d1/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    result1ddd = ((2.0*(arg1ddd*result10+arg1dd*result10d0)-2.0*(arg1dd0&
&     *result10d+arg1d*result10dd))*2.0**2*result10**2-(arg1dd*2.0*&
&     result10-arg1d*2.0*result10d)*2*2.0**2*result10*result10d0)/((2.0*&
&     result10)**2)**2
    result1dd = (arg1dd*2.0*result10-arg1d*2.0*result10d)/(2.0*result10)&
&     **2
    result1dd0 = (arg1dd0*2.0*result10-arg1d*2.0*result10d0)/(2.0*&
&     result10)**2
    result1d = arg1d/(2.0*result10)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d0 = 0.d0
    result1d0d = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result11d = 0.D0
    ELSE
      result11d = arg1d1/(2.0*SQRT(arg1))
    END IF
    result11 = SQRT(arg1)
    result1d0d = (arg1d0d*2.0*result11-arg1d0*2.0*result11d)/(2.0*&
&     result11)**2
    result1d0 = arg1d0/(2.0*result11)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d1 = 0.D0
  ELSE
    result1d1 = arg1d1/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpddd = (((sperpddd*result1+sperpdd*result1d1+sperpdd0*result1d0+&
&   sperpd*result1d0d-sperpd0d*result1d-sperpd0*result1dd0-sperpd1*&
&   result1dd-sperp*result1ddd)*result1**2+(sperpdd*result1+sperpd*&
&   result1d0-sperpd0*result1d-sperp*result1dd)*2*result1*result1d1-2*((&
&   sperpdd0*result1+sperpd*result1d1-sperpd1*result1d-sperp*result1dd0)&
&   *result1*result1d0)-2*((sperpd*result1-sperp*result1d)*(result1d1*&
&   result1d0+result1*result1d0d)))*result1**4-((sperpdd*result1+sperpd*&
&   result1d0-sperpd0*result1d-sperp*result1dd)*result1**2-(sperpd*&
&   result1-sperp*result1d)*2*result1*result1d0)*2**2*result1**3*&
&   result1d1)/((result1**2)**2)**2
  sperpdd = ((sperpdd*result1+sperpd*result1d0-sperpd0*result1d-sperp*&
&   result1dd)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d0)/(result1**2)**2
  sperpdd0 = ((sperpdd0*result1+sperpd*result1d1-sperpd1*result1d-sperp*&
&   result1dd0)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d1)/(result1**2)**2
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperpd0d = ((sperpd0d*result1+sperpd0*result1d1-sperpd1*result1d0-&
&   sperp*result1d0d)*result1**2-(sperpd0*result1-sperp*result1d0)*2*&
&   result1*result1d1)/(result1**2)**2
  sperpd0 = (sperpd0*result1-sperp*result1d0)/result1**2
  sperpd1 = (sperpd1*result1-sperp*result1d1)/result1**2
  sperp = sperp/result1
  calphadddd = alphad*alphad0*alphad1*alphad2*COS(alpha)
  calphaddd = alphad*alphad0*alphad1*SIN(alpha)
  calphaddd0 = alphad*alphad0*alphad2*SIN(alpha)
  calphadd = -(alphad*alphad0*COS(alpha))
  calphadd0d = alphad*alphad1*alphad2*SIN(alpha)
  calphadd0 = -(alphad*alphad1*COS(alpha))
  calphadd1 = -(alphad*alphad2*COS(alpha))
  calphad = -(alphad*SIN(alpha))
  calphad0dd = alphad0*alphad1*alphad2*SIN(alpha)
  calphad0d = -(alphad0*alphad1*COS(alpha))
  calphad0d0 = -(alphad0*alphad2*COS(alpha))
  calphad0 = -(alphad0*SIN(alpha))
  calphad1d = -(alphad1*alphad2*COS(alpha))
  calphad1 = -(alphad1*SIN(alpha))
  calphad2 = -(alphad2*SIN(alpha))
  calpha = COS(alpha)
  salphadddd = alphad*alphad0*alphad1*alphad2*SIN(alpha)
  salphaddd = -(alphad*alphad0*alphad1*COS(alpha))
  salphaddd0 = -(alphad*alphad0*alphad2*COS(alpha))
  salphadd = -(alphad*alphad0*SIN(alpha))
  salphadd0d = -(alphad*alphad1*alphad2*COS(alpha))
  salphadd0 = -(alphad*alphad1*SIN(alpha))
  salphadd1 = -(alphad*alphad2*SIN(alpha))
  salphad = alphad*COS(alpha)
  salphad0dd = -(alphad0*alphad1*alphad2*COS(alpha))
  salphad0d = -(alphad0*alphad1*SIN(alpha))
  salphad0d0 = -(alphad0*alphad2*SIN(alpha))
  salphad0 = alphad0*COS(alpha)
  salphad1d = -(alphad1*alphad2*SIN(alpha))
  salphad1 = alphad1*COS(alpha)
  salphad2 = alphad2*COS(alpha)
  salpha = SIN(alpha)
! Optimal force
  fsdddd = b1*calphadddd + (b2*2*(calphad0dd*calphad+calphad0d*calphadd1&
&   +calphad0d0*calphadd0+calphad0*calphadd0d+calphad1d*calphadd+&
&   calphad1*calphaddd0+calphad2*calphaddd+calpha*calphadddd)+b3*&
&   calphadddd)*calpha + (b2*2*(calphad0d*calphad+calphad0*calphadd0+&
&   calphad1*calphadd+calpha*calphaddd)+b3*calphaddd)*calphad2 + (b2*2*(&
&   calphad0d0*calphad+calphad0*calphadd1+calphad2*calphadd+calpha*&
&   calphaddd0)+b3*calphaddd0)*calphad1 + (b2*2*(calphad0*calphad+calpha&
&   *calphadd)+b3*calphadd)*calphad1d + (b2*2*(calphad1d*calphad+&
&   calphad1*calphadd1+calphad2*calphadd0+calpha*calphadd0d)+b3*&
&   calphadd0d)*calphad0 + (b2*2*(calphad1*calphad+calpha*calphadd0)+b3*&
&   calphadd0)*calphad0d0 + (b2*2*(calphad2*calphad+calpha*calphadd1)+b3&
&   *calphadd1)*calphad0d + (b2*2*calpha*calphad+b3*calphad)*calphad0dd &
&   + (b2*2*(calphad1d*calphad0+calphad1*calphad0d0+calphad2*calphad0d+&
&   calpha*calphad0dd)+b3*calphad0dd)*calphad + (b2*2*(calphad1*calphad0&
&   +calpha*calphad0d)+b3*calphad0d)*calphadd1 + (b2*2*(calphad2*&
&   calphad0+calpha*calphad0d0)+b3*calphad0d0)*calphadd0 + (b2*2*calpha*&
&   calphad0+b3*calphad0)*calphadd0d + (b2*2*(calphad2*calphad1+calpha*&
&   calphad1d)+b3*calphad1d)*calphadd + (b2*2*calpha*calphad1+b3*&
&   calphad1)*calphaddd0 + (b2*2*calpha*calphad2+b3*calphad2)*calphaddd &
&   + (b2*calpha**2+b3*calpha)*calphadddd
  fsddd = b1*calphaddd + (b2*2*(calphad0d*calphad+calphad0*calphadd0+&
&   calphad1*calphadd+calpha*calphaddd)+b3*calphaddd)*calpha + (b2*2*(&
&   calphad0*calphad+calpha*calphadd)+b3*calphadd)*calphad1 + (b2*2*(&
&   calphad1*calphad+calpha*calphadd0)+b3*calphadd0)*calphad0 + (b2*2*&
&   calpha*calphad+b3*calphad)*calphad0d + (b2*2*(calphad1*calphad0+&
&   calpha*calphad0d)+b3*calphad0d)*calphad + (b2*2*calpha*calphad0+b3*&
&   calphad0)*calphadd0 + (b2*2*calpha*calphad1+b3*calphad1)*calphadd + &
&   (b2*calpha**2+b3*calpha)*calphaddd
  fsddd0 = b1*calphaddd0 + (b2*2*(calphad0d0*calphad+calphad0*calphadd1+&
&   calphad2*calphadd+calpha*calphaddd0)+b3*calphaddd0)*calpha + (b2*2*(&
&   calphad0*calphad+calpha*calphadd)+b3*calphadd)*calphad2 + (b2*2*(&
&   calphad2*calphad+calpha*calphadd1)+b3*calphadd1)*calphad0 + (b2*2*&
&   calpha*calphad+b3*calphad)*calphad0d0 + (b2*2*(calphad2*calphad0+&
&   calpha*calphad0d0)+b3*calphad0d0)*calphad + (b2*2*calpha*calphad0+b3&
&   *calphad0)*calphadd1 + (b2*2*calpha*calphad2+b3*calphad2)*calphadd +&
&   (b2*calpha**2+b3*calpha)*calphaddd0
  fsdd = b1*calphadd + (b2*2*(calphad0*calphad+calpha*calphadd)+b3*&
&   calphadd)*calpha + (b2*2*calpha*calphad+b3*calphad)*calphad0 + (b2*2&
&   *calpha*calphad0+b3*calphad0)*calphad + (b2*calpha**2+b3*calpha)*&
&   calphadd
  fsdd0d = b1*calphadd0d + (b2*2*(calphad1d*calphad+calphad1*calphadd1+&
&   calphad2*calphadd0+calpha*calphadd0d)+b3*calphadd0d)*calpha + (b2*2*&
&   (calphad1*calphad+calpha*calphadd0)+b3*calphadd0)*calphad2 + (b2*2*(&
&   calphad2*calphad+calpha*calphadd1)+b3*calphadd1)*calphad1 + (b2*2*&
&   calpha*calphad+b3*calphad)*calphad1d + (b2*2*(calphad2*calphad1+&
&   calpha*calphad1d)+b3*calphad1d)*calphad + (b2*2*calpha*calphad1+b3*&
&   calphad1)*calphadd1 + (b2*2*calpha*calphad2+b3*calphad2)*calphadd0 +&
&   (b2*calpha**2+b3*calpha)*calphadd0d
  fsdd0 = b1*calphadd0 + (b2*2*(calphad1*calphad+calpha*calphadd0)+b3*&
&   calphadd0)*calpha + (b2*2*calpha*calphad+b3*calphad)*calphad1 + (b2*&
&   2*calpha*calphad1+b3*calphad1)*calphad + (b2*calpha**2+b3*calpha)*&
&   calphadd0
  fsdd1 = b1*calphadd1 + (b2*2*(calphad2*calphad+calpha*calphadd1)+b3*&
&   calphadd1)*calpha + (b2*2*calpha*calphad+b3*calphad)*calphad2 + (b2*&
&   2*calpha*calphad2+b3*calphad2)*calphad + (b2*calpha**2+b3*calpha)*&
&   calphadd1
  fsd = b1*calphad + (b2*2*calpha*calphad+b3*calphad)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad
  fsd0dd = b1*calphad0dd + (b2*2*(calphad1d*calphad0+calphad1*calphad0d0&
&   +calphad2*calphad0d+calpha*calphad0dd)+b3*calphad0dd)*calpha + (b2*2&
&   *(calphad1*calphad0+calpha*calphad0d)+b3*calphad0d)*calphad2 + (b2*2&
&   *(calphad2*calphad0+calpha*calphad0d0)+b3*calphad0d0)*calphad1 + (b2&
&   *2*calpha*calphad0+b3*calphad0)*calphad1d + (b2*2*(calphad2*calphad1&
&   +calpha*calphad1d)+b3*calphad1d)*calphad0 + (b2*2*calpha*calphad1+b3&
&   *calphad1)*calphad0d0 + (b2*2*calpha*calphad2+b3*calphad2)*calphad0d&
&   + (b2*calpha**2+b3*calpha)*calphad0dd
  fsd0d = b1*calphad0d + (b2*2*(calphad1*calphad0+calpha*calphad0d)+b3*&
&   calphad0d)*calpha + (b2*2*calpha*calphad0+b3*calphad0)*calphad1 + (&
&   b2*2*calpha*calphad1+b3*calphad1)*calphad0 + (b2*calpha**2+b3*calpha&
&   )*calphad0d
  fsd0d0 = b1*calphad0d0 + (b2*2*(calphad2*calphad0+calpha*calphad0d0)+&
&   b3*calphad0d0)*calpha + (b2*2*calpha*calphad0+b3*calphad0)*calphad2 &
&   + (b2*2*calpha*calphad2+b3*calphad2)*calphad0 + (b2*calpha**2+b3*&
&   calpha)*calphad0d0
  fsd0 = b1*calphad0 + (b2*2*calpha*calphad0+b3*calphad0)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad0
  fsd1d = b1*calphad1d + (b2*2*(calphad2*calphad1+calpha*calphad1d)+b3*&
&   calphad1d)*calpha + (b2*2*calpha*calphad1+b3*calphad1)*calphad2 + (&
&   b2*2*calpha*calphad2+b3*calphad2)*calphad1 + (b2*calpha**2+b3*calpha&
&   )*calphad1d
  fsd1 = b1*calphad1 + (b2*2*calpha*calphad1+b3*calphad1)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad1
  fsd2 = b1*calphad2 + (b2*2*calpha*calphad2+b3*calphad2)*calpha + (b2*&
&   calpha**2+b3*calpha)*calphad2
  fs = b1*calpha + (b2*calpha**2+b3*calpha)*calpha
  fperpdddd = (b2*2*(calphad0dd*calphad+calphad0d*calphadd1+calphad0d0*&
&   calphadd0+calphad0*calphadd0d+calphad1d*calphadd+calphad1*calphaddd0&
&   +calphad2*calphaddd+calpha*calphadddd)+b3*calphadddd)*salpha + (b2*2&
&   *(calphad0d*calphad+calphad0*calphadd0+calphad1*calphadd+calpha*&
&   calphaddd)+b3*calphaddd)*salphad2 + (b2*2*(calphad0d0*calphad+&
&   calphad0*calphadd1+calphad2*calphadd+calpha*calphaddd0)+b3*&
&   calphaddd0)*salphad1 + (b2*2*(calphad0*calphad+calpha*calphadd)+b3*&
&   calphadd)*salphad1d + (b2*2*(calphad1d*calphad+calphad1*calphadd1+&
&   calphad2*calphadd0+calpha*calphadd0d)+b3*calphadd0d)*salphad0 + (b2*&
&   2*(calphad1*calphad+calpha*calphadd0)+b3*calphadd0)*salphad0d0 + (b2&
&   *2*(calphad2*calphad+calpha*calphadd1)+b3*calphadd1)*salphad0d + (b2&
&   *2*calpha*calphad+b3*calphad)*salphad0dd + (b2*2*(calphad1d*calphad0&
&   +calphad1*calphad0d0+calphad2*calphad0d+calpha*calphad0dd)+b3*&
&   calphad0dd)*salphad + (b2*2*(calphad1*calphad0+calpha*calphad0d)+b3*&
&   calphad0d)*salphadd1 + (b2*2*(calphad2*calphad0+calpha*calphad0d0)+&
&   b3*calphad0d0)*salphadd0 + (b2*2*calpha*calphad0+b3*calphad0)*&
&   salphadd0d + (b2*2*(calphad2*calphad1+calpha*calphad1d)+b3*calphad1d&
&   )*salphadd + (b2*2*calpha*calphad1+b3*calphad1)*salphaddd0 + (b2*2*&
&   calpha*calphad2+b3*calphad2)*salphaddd + (b2*calpha**2+b3*calpha)*&
&   salphadddd
  fperpddd = (b2*2*(calphad0d*calphad+calphad0*calphadd0+calphad1*&
&   calphadd+calpha*calphaddd)+b3*calphaddd)*salpha + (b2*2*(calphad0*&
&   calphad+calpha*calphadd)+b3*calphadd)*salphad1 + (b2*2*(calphad1*&
&   calphad+calpha*calphadd0)+b3*calphadd0)*salphad0 + (b2*2*calpha*&
&   calphad+b3*calphad)*salphad0d + (b2*2*(calphad1*calphad0+calpha*&
&   calphad0d)+b3*calphad0d)*salphad + (b2*2*calpha*calphad0+b3*calphad0&
&   )*salphadd0 + (b2*2*calpha*calphad1+b3*calphad1)*salphadd + (b2*&
&   calpha**2+b3*calpha)*salphaddd
  fperpddd0 = (b2*2*(calphad0d0*calphad+calphad0*calphadd1+calphad2*&
&   calphadd+calpha*calphaddd0)+b3*calphaddd0)*salpha + (b2*2*(calphad0*&
&   calphad+calpha*calphadd)+b3*calphadd)*salphad2 + (b2*2*(calphad2*&
&   calphad+calpha*calphadd1)+b3*calphadd1)*salphad0 + (b2*2*calpha*&
&   calphad+b3*calphad)*salphad0d0 + (b2*2*(calphad2*calphad0+calpha*&
&   calphad0d0)+b3*calphad0d0)*salphad + (b2*2*calpha*calphad0+b3*&
&   calphad0)*salphadd1 + (b2*2*calpha*calphad2+b3*calphad2)*salphadd + &
&   (b2*calpha**2+b3*calpha)*salphaddd0
  fperpdd = (b2*2*(calphad0*calphad+calpha*calphadd)+b3*calphadd)*salpha&
&   + (b2*2*calpha*calphad+b3*calphad)*salphad0 + (b2*2*calpha*calphad0+&
&   b3*calphad0)*salphad + (b2*calpha**2+b3*calpha)*salphadd
  fperpdd0d = (b2*2*(calphad1d*calphad+calphad1*calphadd1+calphad2*&
&   calphadd0+calpha*calphadd0d)+b3*calphadd0d)*salpha + (b2*2*(calphad1&
&   *calphad+calpha*calphadd0)+b3*calphadd0)*salphad2 + (b2*2*(calphad2*&
&   calphad+calpha*calphadd1)+b3*calphadd1)*salphad1 + (b2*2*calpha*&
&   calphad+b3*calphad)*salphad1d + (b2*2*(calphad2*calphad1+calpha*&
&   calphad1d)+b3*calphad1d)*salphad + (b2*2*calpha*calphad1+b3*calphad1&
&   )*salphadd1 + (b2*2*calpha*calphad2+b3*calphad2)*salphadd0 + (b2*&
&   calpha**2+b3*calpha)*salphadd0d
  fperpdd0 = (b2*2*(calphad1*calphad+calpha*calphadd0)+b3*calphadd0)*&
&   salpha + (b2*2*calpha*calphad+b3*calphad)*salphad1 + (b2*2*calpha*&
&   calphad1+b3*calphad1)*salphad + (b2*calpha**2+b3*calpha)*salphadd0
  fperpdd1 = (b2*2*(calphad2*calphad+calpha*calphadd1)+b3*calphadd1)*&
&   salpha + (b2*2*calpha*calphad+b3*calphad)*salphad2 + (b2*2*calpha*&
&   calphad2+b3*calphad2)*salphad + (b2*calpha**2+b3*calpha)*salphadd1
  fperpd = (b2*2*calpha*calphad+b3*calphad)*salpha + (b2*calpha**2+b3*&
&   calpha)*salphad
  fperpd0dd = (b2*2*(calphad1d*calphad0+calphad1*calphad0d0+calphad2*&
&   calphad0d+calpha*calphad0dd)+b3*calphad0dd)*salpha + (b2*2*(calphad1&
&   *calphad0+calpha*calphad0d)+b3*calphad0d)*salphad2 + (b2*2*(calphad2&
&   *calphad0+calpha*calphad0d0)+b3*calphad0d0)*salphad1 + (b2*2*calpha*&
&   calphad0+b3*calphad0)*salphad1d + (b2*2*(calphad2*calphad1+calpha*&
&   calphad1d)+b3*calphad1d)*salphad0 + (b2*2*calpha*calphad1+b3*&
&   calphad1)*salphad0d0 + (b2*2*calpha*calphad2+b3*calphad2)*salphad0d &
&   + (b2*calpha**2+b3*calpha)*salphad0dd
  fperpd0d = (b2*2*(calphad1*calphad0+calpha*calphad0d)+b3*calphad0d)*&
&   salpha + (b2*2*calpha*calphad0+b3*calphad0)*salphad1 + (b2*2*calpha*&
&   calphad1+b3*calphad1)*salphad0 + (b2*calpha**2+b3*calpha)*salphad0d
  fperpd0d0 = (b2*2*(calphad2*calphad0+calpha*calphad0d0)+b3*calphad0d0)&
&   *salpha + (b2*2*calpha*calphad0+b3*calphad0)*salphad2 + (b2*2*calpha&
&   *calphad2+b3*calphad2)*salphad0 + (b2*calpha**2+b3*calpha)*&
&   salphad0d0
  fperpd0 = (b2*2*calpha*calphad0+b3*calphad0)*salpha + (b2*calpha**2+b3&
&   *calpha)*salphad0
  fperpd1d = (b2*2*(calphad2*calphad1+calpha*calphad1d)+b3*calphad1d)*&
&   salpha + (b2*2*calpha*calphad1+b3*calphad1)*salphad2 + (b2*2*calpha*&
&   calphad2+b3*calphad2)*salphad1 + (b2*calpha**2+b3*calpha)*salphad1d
  fperpd1 = (b2*2*calpha*calphad1+b3*calphad1)*salpha + (b2*calpha**2+b3&
&   *calpha)*salphad1
  fperpd2 = (b2*2*calpha*calphad2+b3*calphad2)*salpha + (b2*calpha**2+b3&
&   *calpha)*salphad2
  fperp = (b2*calpha**2+b3*calpha)*salpha
  udddd = sdir*fsdddd + sperpd0d*fperpdd + sperpd0*fperpddd0 + sperpd1*&
&   fperpddd + sperp*fperpdddd + sperpddd*fperpd0 + sperpdd*fperpd0d0 + &
&   sperpdd0*fperpd0d + sperpd*fperpd0dd
  uddd = sdir*fsddd + sperpd0*fperpdd + sperp*fperpddd + sperpdd*fperpd0&
&   + sperpd*fperpd0d
  uddd0 = sdir*fsddd0 + sperpd1*fperpdd + sperp*fperpddd0 + sperpdd0*&
&   fperpd0 + sperpd*fperpd0d0
  udd = sdir*fsdd + sperp*fperpdd + sperpd*fperpd0
  udd0d = sdir*fsdd0d + fperpdd0d*sperp + fperpdd0*sperpd1 + fperpdd1*&
&   sperpd0 + fperpd*sperpd0d + fperpd1d*sperpd + fperpd1*sperpdd0 + &
&   fperpd2*sperpdd + fperp*sperpddd
  udd0 = sdir*fsdd0 + fperpdd0*sperp + fperpd*sperpd0 + fperpd1*sperpd +&
&   fperp*sperpdd
  udd1 = sdir*fsdd1 + fperpdd1*sperp + fperpd*sperpd1 + fperpd2*sperpd +&
&   fperp*sperpdd0
  ud = sdir*fsd + fperpd*sperp + fperp*sperpd
  ud0dd = sdir*fsd0dd + sperpd0d*fperpd0 + sperpd0*fperpd0d0 + sperpd1*&
&   fperpd0d + sperp*fperpd0dd
  ud0d = sdir*fsd0d + sperpd0*fperpd0 + sperp*fperpd0d
  ud0d0 = sdir*fsd0d0 + sperpd1*fperpd0 + sperp*fperpd0d0
  ud0 = sdir*fsd0 + sperp*fperpd0
  ud1d = sdir*fsd1d + fperpd1d*sperp + fperpd1*sperpd1 + fperpd2*sperpd0&
&   + fperp*sperpd0d
  ud1 = sdir*fsd1 + fperpd1*sperp + fperp*sperpd0
  ud2 = sdir*fsd2 + fperpd2*sperp + fperp*sperpd1
  u = fs*sdir + fperp*sperp
END SUBROUTINE PMPSAIL_DA_DA_DI_DI

!  Differentiation of dot_da_da_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resdd resd res resddd resd0
!                resdd0
!   with respect to varying inputs: u v vd0d ud udd vddd vd0 vd1
!                vd ud0 vdd0 vdd
!  Differentiation of dot_da_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resdd resd res
!   with respect to varying inputs: u v ud vd0 vd vdd
!  Differentiation of dot_da in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd
!   with respect to varying inputs: v vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DA_DA_DI_DI(n, u, ud1, ud0, ud0d, ud, udd0, udd, uddd, v&
& , vd2, vd1, vd1d, vd0, vd0d0, vd0d, vd0dd, vd, vdd1, vdd0, vdd0d, vdd&
& , vddd0, vddd, vdddd, res, resd1, resd0, resd0d, resd, resdd1, resdd0&
& , resdd0d, resdd, resddd0, resddd, resdddd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud1(n), vd2(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd1(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0d(n), vd1d(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0d0(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0d(n)
  DOUBLE PRECISION, INTENT(IN) :: vd0dd(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: udd0(n), vdd1(n)
  DOUBLE PRECISION, INTENT(IN) :: udd(n), vdd0(n)
  DOUBLE PRECISION, INTENT(IN) :: uddd(n), vdd0d(n)
  DOUBLE PRECISION, INTENT(IN) :: vdd(n)
  DOUBLE PRECISION, INTENT(IN) :: vddd0(n)
  DOUBLE PRECISION, INTENT(IN) :: vddd(n)
  DOUBLE PRECISION, INTENT(IN) :: vdddd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd1
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd0d
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd1
  DOUBLE PRECISION, INTENT(OUT) :: resdd0
  DOUBLE PRECISION, INTENT(OUT) :: resdd0d
  DOUBLE PRECISION, INTENT(OUT) :: resdd
  DOUBLE PRECISION, INTENT(OUT) :: resddd0
  DOUBLE PRECISION, INTENT(OUT) :: resddd
  DOUBLE PRECISION, INTENT(OUT) :: resdddd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.d0
  resddd = 0.d0
  resdd0 = 0.d0
  resd0 = 0.d0
  resddd0 = 0.D0
  resdd1 = 0.D0
  resd1 = 0.D0
  resdddd = 0.D0
  resd0d = 0.D0
  resdd0d = 0.D0
  DO i=1,n
    resdddd = resdddd + uddd(i)*vd0(i) + udd(i)*vd0d0(i) + udd0(i)*vd0d(&
&     i) + ud(i)*vd0dd(i) + ud0d(i)*vdd(i) + ud0(i)*vddd0(i) + ud1(i)*&
&     vddd(i) + u(i)*vdddd(i)
    resddd = resddd + udd(i)*vd0(i) + ud(i)*vd0d(i) + ud0(i)*vdd(i) + u(&
&     i)*vddd(i)
    resddd0 = resddd0 + udd0(i)*vd0(i) + ud(i)*vd0d0(i) + ud1(i)*vdd(i) &
&     + u(i)*vddd0(i)
    resdd = resdd + ud(i)*vd0(i) + u(i)*vdd(i)
    resdd0d = resdd0d + uddd(i)*v(i) + udd(i)*vd2(i) + udd0(i)*vd1(i) + &
&     ud(i)*vd1d(i) + ud0d(i)*vd(i) + ud0(i)*vdd1(i) + ud1(i)*vdd0(i) + &
&     u(i)*vdd0d(i)
    resdd0 = resdd0 + udd(i)*v(i) + ud(i)*vd1(i) + ud0(i)*vd(i) + u(i)*&
&     vdd0(i)
    resdd1 = resdd1 + udd0(i)*v(i) + ud(i)*vd2(i) + ud1(i)*vd(i) + u(i)*&
&     vdd1(i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0d = resd0d + ud0d(i)*v(i) + ud0(i)*vd2(i) + ud1(i)*vd1(i) + u(i&
&     )*vd1d(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd1(i)
    resd1 = resd1 + ud1(i)*v(i) + u(i)*vd2(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DA_DA_DI_DI

!  Differentiation of hfuncone_dc_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hconed hconedd
!   with respect to varying inputs: pdeltai m
!  Differentiation of hfuncone_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hconed
!   with respect to varying inputs: pdeltai m
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfuncone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hcone
!   with respect to varying inputs: pdeltai m
!   RW status of diff variables: pdeltai:in m:in hcone:out
!Calcul of hcone
SUBROUTINE HFUNCONE_DC_DI_DI(m, md1, md0, md, pdeltai, pdeltaid1, &
& pdeltaid0, pdeltaid, pars, hcone, hconed, hconedd0, hconedd, hconeddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pdeltai(5), m, pars(11)
  DOUBLE PRECISION, INTENT(IN) :: pdeltaid1(5), md1
  DOUBLE PRECISION, INTENT(IN) :: pdeltaid0(5), md0
  DOUBLE PRECISION :: pdeltaid0d(5)
  DOUBLE PRECISION, INTENT(IN) :: pdeltaid(5), md
  DOUBLE PRECISION :: pdeltaidd0(5)
  DOUBLE PRECISION :: pdeltaidd(5)
  DOUBLE PRECISION :: pdeltaiddd(5)
  DOUBLE PRECISION, INTENT(OUT) :: hcone
  DOUBLE PRECISION :: hconed1
  DOUBLE PRECISION :: hconed0
  DOUBLE PRECISION :: hconed0d
  DOUBLE PRECISION, INTENT(OUT) :: hconed
  DOUBLE PRECISION, INTENT(OUT) :: hconedd0
  DOUBLE PRECISION, INTENT(OUT) :: hconedd
  DOUBLE PRECISION, INTENT(OUT) :: hconeddd
! local variables
  DOUBLE PRECISION :: fx(6), fy(6), fz(6), pig(3), sdir(3), mu, fcone(2)&
& , ucone(3), i(5)
  DOUBLE PRECISION :: fxd1(6), fyd1(6), fzd1(6), pigd1(3), uconed1(3)
  DOUBLE PRECISION :: fxd0(6), fyd0(6), fzd0(6), pigd0(3), uconed0(3)
  DOUBLE PRECISION :: fxd0d(6), fyd0d(6), fzd0d(6), pigd0d(3), uconed0d(&
& 3)
  DOUBLE PRECISION :: fxd(6), fyd(6), fzd(6), pigd(3), uconed(3)
  DOUBLE PRECISION :: fxdd0(6), fydd0(6), fzdd0(6), pigdd0(3), uconedd0(&
& 3)
  DOUBLE PRECISION :: fxdd(6), fydd(6), fzdd(6), pigdd(3), uconedd(3)
  DOUBLE PRECISION :: fxddd(6), fyddd(6), fzddd(6), pigddd(3), uconeddd(&
& 3)
  mu = pars(1)
! Orbital elements
  i = pars(2:6)
! Forces on convex cone
  fcone = pars(7:8)
  sdir = (/0.0d0, 0.0d0, -1.0d0/)
  CALL GVEECI_DC_DI_DI(m, md1, md0, md, i, mu, fx, fxd1, fxd0, fxd0d, &
&                fxd, fxdd0, fxdd, fxddd, fy, fyd1, fyd0, fyd0d, fyd, &
&                fydd0, fydd, fyddd, fz, fzd1, fzd0, fzd0d, fzd, fzdd0, &
&                fzdd, fzddd)
  pdeltaidd = 0.d0
  pdeltaiddd = 0.D0
  pdeltaidd0 = 0.D0
  pdeltaid0d = 0.D0
  CALL DOT_DC_DI_DI(5, pdeltai, pdeltaid1, pdeltaid0, pdeltaid0d, &
&             pdeltaid, pdeltaidd0, pdeltaidd, pdeltaiddd, fx, fxd1, &
&             fxd0, fxd0d, fxd, fxdd0, fxdd, fxddd, pig(1), pigd1(1), &
&             pigd0(1), pigd0d(1), pigd(1), pigdd0(1), pigdd(1), pigddd(&
&             1))
  pdeltaidd = 0.d0
  pdeltaiddd = 0.D0
  pdeltaidd0 = 0.D0
  pdeltaid0d = 0.D0
  CALL DOT_DC_DI_DI(5, pdeltai, pdeltaid1, pdeltaid0, pdeltaid0d, &
&             pdeltaid, pdeltaidd0, pdeltaidd, pdeltaiddd, fy, fyd1, &
&             fyd0, fyd0d, fyd, fydd0, fydd, fyddd, pig(2), pigd1(2), &
&             pigd0(2), pigd0d(2), pigd(2), pigdd0(2), pigdd(2), pigddd(&
&             2))
  pdeltaidd = 0.d0
  pdeltaiddd = 0.D0
  pdeltaidd0 = 0.D0
  pdeltaid0d = 0.D0
  CALL DOT_DC_DI_DI(5, pdeltai, pdeltaid1, pdeltaid0, pdeltaid0d, &
&             pdeltaid, pdeltaidd0, pdeltaidd, pdeltaiddd, fz, fzd1, &
&             fzd0, fzd0d, fzd, fzdd0, fzdd, fzddd, pig(3), pigd1(3), &
&             pigd0(3), pigd0d(3), pigd(3), pigdd0(3), pigdd(3), pigddd(&
&             3))
! Hamiltonian of the cone
  CALL PMPCONE_DC_DI_DI(pig, pigd1, pigd0, pigd0d, pigd, pigdd0, pigdd, &
&                 pigddd, sdir, fcone, ucone, uconed1, uconed0, uconed0d&
&                 , uconed, uconedd0, uconedd, uconeddd)
  CALL DOT_DC_DI_DI(3, pig, pigd1, pigd0, pigd0d, pigd, pigdd0, pigdd, &
&             pigddd, ucone, uconed1, uconed0, uconed0d, uconed, &
&             uconedd0, uconedd, uconeddd, hcone, hconed1, hconed0, &
&             hconed0d, hconed, hconedd0, hconedd, hconeddd)
END SUBROUTINE HFUNCONE_DC_DI_DI

!  Differentiation of pmpcone_dc_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud udd ud0
!   with respect to varying inputs: pigd0 pigdd pigd pig
!  Differentiation of pmpcone_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u ud
!   with respect to varying inputs: pigd pig
!  Differentiation of pmpcone in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: pig
!#######################################################################
!## PMP of the cone
SUBROUTINE PMPCONE_DC_DI_DI(pig, pigd1, pigd0, pigd0d, pigd, pigdd0, &
& pigdd, pigddd, sdir, fcone, u, ud1, ud0, ud0d, ud, udd0, udd, uddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: pig(3), sdir(3), fcone(2)
  DOUBLE PRECISION, INTENT(IN) :: pigd1(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd0(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd0d(3)
  DOUBLE PRECISION, INTENT(IN) :: pigd(3)
  DOUBLE PRECISION, INTENT(IN) :: pigdd0(3)
  DOUBLE PRECISION, INTENT(IN) :: pigdd(3)
  DOUBLE PRECISION, INTENT(IN) :: pigddd(3)
  DOUBLE PRECISION, INTENT(OUT) :: u(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud1(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud0d(3)
  DOUBLE PRECISION, INTENT(OUT) :: ud(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd0(3)
  DOUBLE PRECISION, INTENT(OUT) :: udd(3)
  DOUBLE PRECISION, INTENT(OUT) :: uddd(3)
! local variables
  DOUBLE PRECISION :: sperp(3)
  DOUBLE PRECISION :: sperpd1(3)
  DOUBLE PRECISION :: sperpd0(3)
  DOUBLE PRECISION :: sperpd0d(3)
  DOUBLE PRECISION :: sperpd(3)
  DOUBLE PRECISION :: sperpdd0(3)
  DOUBLE PRECISION :: sperpdd(3)
  DOUBLE PRECISION :: sperpddd(3)
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d0d
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd0
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: arg1ddd
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d1
  DOUBLE PRECISION :: result1d0
  DOUBLE PRECISION :: result1d0d
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result1dd0
  DOUBLE PRECISION :: result1dd
  DOUBLE PRECISION :: result1ddd
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d0
  DOUBLE PRECISION :: result10d
  DOUBLE PRECISION :: result10dd
  DOUBLE PRECISION :: result11
  DOUBLE PRECISION :: result11d
  sperpddd = pigddd - sdir*(sdir(1)*pigddd(1)+sdir(2)*pigddd(2)+sdir(3)*&
&   pigddd(3))
  sperpdd = pigdd - sdir*(sdir(1)*pigdd(1)+sdir(2)*pigdd(2)+sdir(3)*&
&   pigdd(3))
  sperpdd0 = pigdd0 - sdir*(sdir(1)*pigdd0(1)+sdir(2)*pigdd0(2)+sdir(3)*&
&   pigdd0(3))
  sperpd = pigd - sdir*(sdir(1)*pigd(1)+sdir(2)*pigd(2)+sdir(3)*pigd(3))
  sperpd0d = pigd0d - sdir*(sdir(1)*pigd0d(1)+sdir(2)*pigd0d(2)+sdir(3)*&
&   pigd0d(3))
  sperpd0 = pigd0 - sdir*(sdir(1)*pigd0(1)+sdir(2)*pigd0(2)+sdir(3)*&
&   pigd0(3))
  sperpd1 = pigd1 - sdir*(sdir(1)*pigd1(1)+sdir(2)*pigd1(2)+sdir(3)*&
&   pigd1(3))
  sperp = pig - (pig(1)*sdir(1)+pig(2)*sdir(2)+pig(3)*sdir(3))*sdir
  arg1ddd = 2*(sperpd0d(1)*sperpd(1)) + 2*(sperpd0(1)*sperpdd0(1)) + 2*(&
&   sperpd1(1)*sperpdd(1)) + 2*(sperp(1)*sperpddd(1)) + 2*(sperpd0d(2)*&
&   sperpd(2)) + 2*(sperpd0(2)*sperpdd0(2)) + 2*(sperpd1(2)*sperpdd(2)) &
&   + 2*(sperp(2)*sperpddd(2)) + 2*(sperpd0d(3)*sperpd(3)) + 2*(sperpd0(&
&   3)*sperpdd0(3)) + 2*(sperpd1(3)*sperpdd(3)) + 2*(sperp(3)*sperpddd(3&
&   ))
  arg1dd = 2*(sperpd0(1)*sperpd(1)) + 2*(sperp(1)*sperpdd(1)) + 2*(&
&   sperpd0(2)*sperpd(2)) + 2*(sperp(2)*sperpdd(2)) + 2*(sperpd0(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd(3))
  arg1dd0 = 2*(sperpd1(1)*sperpd(1)) + 2*(sperp(1)*sperpdd0(1)) + 2*(&
&   sperpd1(2)*sperpd(2)) + 2*(sperp(2)*sperpdd0(2)) + 2*(sperpd1(3)*&
&   sperpd(3)) + 2*(sperp(3)*sperpdd0(3))
  arg1d = 2*sperp(1)*sperpd(1) + 2*sperp(2)*sperpd(2) + 2*sperp(3)*&
&   sperpd(3)
  arg1d0d = 2*(sperpd1(1)*sperpd0(1)) + 2*(sperp(1)*sperpd0d(1)) + 2*(&
&   sperpd1(2)*sperpd0(2)) + 2*(sperp(2)*sperpd0d(2)) + 2*(sperpd1(3)*&
&   sperpd0(3)) + 2*(sperp(3)*sperpd0d(3))
  arg1d0 = 2*sperp(1)*sperpd0(1) + 2*sperp(2)*sperpd0(2) + 2*sperp(3)*&
&   sperpd0(3)
  arg1d1 = 2*sperp(1)*sperpd1(1) + 2*sperp(2)*sperpd1(2) + 2*sperp(3)*&
&   sperpd1(3)
  arg1 = sperp(1)**2 + sperp(2)**2 + sperp(3)**2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
    result1dd = 0.d0
    result1ddd = 0.D0
    result1dd0 = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.d0
      result10dd = 0.D0
    ELSE
      IF (arg1 .EQ. 0.0) THEN
        result11d = 0.D0
      ELSE
        result11d = arg1d1/(2.0*SQRT(arg1))
      END IF
      result11 = SQRT(arg1)
      result10dd = (arg1d0d*2.0*result11-arg1d0*2.0*result11d)/(2.0*&
&       result11)**2
      result10d = arg1d0/(2.0*result11)
    END IF
    IF (arg1 .EQ. 0.0) THEN
      result10d0 = 0.D0
    ELSE
      result10d0 = arg1d1/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    result1ddd = ((2.0*(arg1ddd*result10+arg1dd*result10d0)-2.0*(arg1dd0&
&     *result10d+arg1d*result10dd))*2.0**2*result10**2-(arg1dd*2.0*&
&     result10-arg1d*2.0*result10d)*2*2.0**2*result10*result10d0)/((2.0*&
&     result10)**2)**2
    result1dd = (arg1dd*2.0*result10-arg1d*2.0*result10d)/(2.0*result10)&
&     **2
    result1dd0 = (arg1dd0*2.0*result10-arg1d*2.0*result10d0)/(2.0*&
&     result10)**2
    result1d = arg1d/(2.0*result10)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d0 = 0.d0
    result1d0d = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result11d = 0.D0
    ELSE
      result11d = arg1d1/(2.0*SQRT(arg1))
    END IF
    result11 = SQRT(arg1)
    result1d0d = (arg1d0d*2.0*result11-arg1d0*2.0*result11d)/(2.0*&
&     result11)**2
    result1d0 = arg1d0/(2.0*result11)
  END IF
  IF (arg1 .EQ. 0.0) THEN
    result1d1 = 0.D0
  ELSE
    result1d1 = arg1d1/(2.0*SQRT(arg1))
  END IF
  result1 = SQRT(arg1)
  sperpddd = (((sperpddd*result1+sperpdd*result1d1+sperpdd0*result1d0+&
&   sperpd*result1d0d-sperpd0d*result1d-sperpd0*result1dd0-sperpd1*&
&   result1dd-sperp*result1ddd)*result1**2+(sperpdd*result1+sperpd*&
&   result1d0-sperpd0*result1d-sperp*result1dd)*2*result1*result1d1-2*((&
&   sperpdd0*result1+sperpd*result1d1-sperpd1*result1d-sperp*result1dd0)&
&   *result1*result1d0)-2*((sperpd*result1-sperp*result1d)*(result1d1*&
&   result1d0+result1*result1d0d)))*result1**4-((sperpdd*result1+sperpd*&
&   result1d0-sperpd0*result1d-sperp*result1dd)*result1**2-(sperpd*&
&   result1-sperp*result1d)*2*result1*result1d0)*2**2*result1**3*&
&   result1d1)/((result1**2)**2)**2
  sperpdd = ((sperpdd*result1+sperpd*result1d0-sperpd0*result1d-sperp*&
&   result1dd)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d0)/(result1**2)**2
  sperpdd0 = ((sperpdd0*result1+sperpd*result1d1-sperpd1*result1d-sperp*&
&   result1dd0)*result1**2-(sperpd*result1-sperp*result1d)*2*result1*&
&   result1d1)/(result1**2)**2
  sperpd = (sperpd*result1-sperp*result1d)/result1**2
  sperpd0d = ((sperpd0d*result1+sperpd0*result1d1-sperpd1*result1d0-&
&   sperp*result1d0d)*result1**2-(sperpd0*result1-sperp*result1d0)*2*&
&   result1*result1d1)/(result1**2)**2
  sperpd0 = (sperpd0*result1-sperp*result1d0)/result1**2
  sperpd1 = (sperpd1*result1-sperp*result1d1)/result1**2
  sperp = sperp/result1
  uddd = fcone(2)*sperpddd
  udd = fcone(2)*sperpdd
  udd0 = fcone(2)*sperpdd0
  ud = fcone(2)*sperpd
  ud0d = fcone(2)*sperpd0d
  ud0 = fcone(2)*sperpd0
  ud1 = fcone(2)*sperpd1
  u = fcone(1)*sdir + fcone(2)*sperp
END SUBROUTINE PMPCONE_DC_DI_DI

!  Differentiation of gveeci_dc_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fxdd fzd fyd0 fzdd fxd fxd0
!                fydd fzd0 fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fzd fxd fyd fx fy fz
!   with respect to varying inputs: m
!  Differentiation of gveeci in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: fx fy fz
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in ECI frame
SUBROUTINE GVEECI_DC_DI_DI(m, md1, md0, md, i, mu, fx, fxd1, fxd0, fxd0d&
& , fxd, fxdd0, fxdd, fxddd, fy, fyd1, fyd0, fyd0d, fyd, fydd0, fydd, &
& fyddd, fz, fzd1, fzd0, fzd0d, fzd, fzdd0, fzdd, fzddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md1
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: fx(6), fy(6), fz(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd1(6), fyd1(6), fzd1(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0(6), fyd0(6), fzd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd0d(6), fyd0d(6), fzd0d(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxd(6), fyd(6), fzd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd0(6), fydd0(6), fzdd0(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxdd(6), fydd(6), fzdd(6)
  DOUBLE PRECISION, INTENT(OUT) :: fxddd(6), fyddd(6), fzddd(6)
! Local variables
  DOUBLE PRECISION :: r(6), t(6), n(6), f, om, inc, w, a, e, theta, som&
& , com, si, ci, sth, cth
  DOUBLE PRECISION :: rd1(6), td1(6), nd1(6), fd1, thetad1, sthd1, cthd1
  DOUBLE PRECISION :: rd0(6), td0(6), nd0(6), fd0, thetad0, sthd0, cthd0
  DOUBLE PRECISION :: rd0d(6), td0d(6), nd0d(6), fd0d, thetad0d, sthd0d&
& , cthd0d
  DOUBLE PRECISION :: rd(6), td(6), nd(6), fd, thetad, sthd, cthd
  DOUBLE PRECISION :: rdd0(6), tdd0(6), ndd0(6), fdd0, thetadd0, sthdd0&
& , cthdd0
  DOUBLE PRECISION :: rdd(6), tdd(6), ndd(6), fdd, thetadd, sthdd, cthdd
  DOUBLE PRECISION :: rddd(6), tddd(6), nddd(6), fddd, thetaddd, sthddd&
& , cthddd
  INTRINSIC SIN
  INTRINSIC COS
! Orbital elements
  om = i(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! GVE in LVLH frame
  CALL GVELVLH_DC_DI_DI(m, md1, md0, md, i, mu, r, rd1, rd0, rd0d, rd, &
&                 rdd0, rdd, rddd, t, td1, td0, td0d, td, tdd0, tdd, &
&                 tddd, n, nd1, nd0, nd0d, nd, ndd0, ndd, nddd, f, fd1, &
&                 fd0, fd0d, fd, fdd0, fdd, fddd)
  thetaddd = fddd
  thetadd = fdd
  thetadd0 = fdd0
  thetad = fd
  thetad0d = fd0d
  thetad0 = fd0
  thetad1 = fd1
  theta = w + f
  som = SIN(om)
  com = COS(om)
  si = SIN(inc)
  ci = COS(inc)
  sthddd = thetaddd*COS(theta) - thetadd*thetad1*SIN(theta) - (thetadd0*&
&   thetad0+thetad*thetad0d)*SIN(theta) - thetad*thetad0*thetad1*COS(&
&   theta)
  sthdd = thetadd*COS(theta) - thetad*thetad0*SIN(theta)
  sthdd0 = thetadd0*COS(theta) - thetad*thetad1*SIN(theta)
  sthd = thetad*COS(theta)
  sthd0d = thetad0d*COS(theta) - thetad0*thetad1*SIN(theta)
  sthd0 = thetad0*COS(theta)
  sthd1 = thetad1*COS(theta)
  sth = SIN(theta)
  cthddd = -(thetaddd*SIN(theta)+thetadd*thetad1*COS(theta)+(thetadd0*&
&   thetad0+thetad*thetad0d)*COS(theta)-thetad*thetad0*thetad1*SIN(theta&
&   ))
  cthdd = -(thetadd*SIN(theta)+thetad*thetad0*COS(theta))
  cthdd0 = -(thetadd0*SIN(theta)+thetad*thetad1*COS(theta))
  cthd = -(thetad*SIN(theta))
  cthd0d = -(thetad0d*SIN(theta)+thetad0*thetad1*COS(theta))
  cthd0 = -(thetad0*SIN(theta))
  cthd1 = -(thetad1*SIN(theta))
  cth = COS(theta)
! GVE in ECI frame
  fxddd = rddd*(-(som*ci*sth)+com*cth) + rdd*(com*cthd1-som*ci*sthd1) + &
&   rdd0*(com*cthd0-som*ci*sthd0) + rd*(com*cthd0d-som*ci*sthd0d) + rd0d&
&   *(com*cthd-som*ci*sthd) + rd0*(com*cthdd0-som*ci*sthdd0) + rd1*(com*&
&   cthdd-som*ci*sthdd) + r*(com*cthddd-som*ci*sthddd) + tddd*(-(som*ci*&
&   cth)-com*sth) + tdd*(-(som*ci*cthd1)-com*sthd1) + tdd0*(-(som*ci*&
&   cthd0)-com*sthd0) + td*(-(som*ci*cthd0d)-com*sthd0d) + td0d*(-(som*&
&   ci*cthd)-com*sthd) + td0*(-(som*ci*cthdd0)-com*sthdd0) + td1*(-(som*&
&   ci*cthdd)-com*sthdd) + t*(-(som*ci*cthddd)-com*sthddd) + som*si*nddd
  fxdd = rdd*(-(som*ci*sth)+com*cth) + rd*(com*cthd0-som*ci*sthd0) + rd0&
&   *(com*cthd-som*ci*sthd) + r*(com*cthdd-som*ci*sthdd) + tdd*(-(som*ci&
&   *cth)-com*sth) + td*(-(som*ci*cthd0)-com*sthd0) + td0*(-(som*ci*cthd&
&   )-com*sthd) + t*(-(som*ci*cthdd)-com*sthdd) + som*si*ndd
  fxdd0 = rdd0*(-(som*ci*sth)+com*cth) + rd*(com*cthd1-som*ci*sthd1) + &
&   rd1*(com*cthd-som*ci*sthd) + r*(com*cthdd0-som*ci*sthdd0) + tdd0*(-(&
&   som*ci*cth)-com*sth) + td*(-(som*ci*cthd1)-com*sthd1) + td1*(-(som*&
&   ci*cthd)-com*sthd) + t*(-(som*ci*cthdd0)-com*sthdd0) + som*si*ndd0
  fxd = rd*(-(som*ci*sth)+com*cth) + r*(com*cthd-som*ci*sthd) + td*(-(&
&   som*ci*cth)-com*sth) + t*(-(som*ci*cthd)-com*sthd) + som*si*nd
  fxd0d = rd0d*(-(som*ci*sth)+com*cth) + rd0*(com*cthd1-som*ci*sthd1) + &
&   rd1*(com*cthd0-som*ci*sthd0) + r*(com*cthd0d-som*ci*sthd0d) + td0d*(&
&   -(som*ci*cth)-com*sth) + td0*(-(som*ci*cthd1)-com*sthd1) + td1*(-(&
&   som*ci*cthd0)-com*sthd0) + t*(-(som*ci*cthd0d)-com*sthd0d) + som*si*&
&   nd0d
  fxd0 = rd0*(-(som*ci*sth)+com*cth) + r*(com*cthd0-som*ci*sthd0) + td0*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd0)-com*sthd0) + som*si*nd0
  fxd1 = rd1*(-(som*ci*sth)+com*cth) + r*(com*cthd1-som*ci*sthd1) + td1*&
&   (-(som*ci*cth)-com*sth) + t*(-(som*ci*cthd1)-com*sthd1) + som*si*nd1
  fx = r*(-(som*ci*sth)+com*cth) + t*(-(som*ci*cth)-com*sth) + n*(som*si&
&   )
  fyddd = rddd*(com*ci*sth+som*cth) + rdd*(com*ci*sthd1+som*cthd1) + &
&   rdd0*(com*ci*sthd0+som*cthd0) + rd*(com*ci*sthd0d+som*cthd0d) + rd0d&
&   *(com*ci*sthd+som*cthd) + rd0*(com*ci*sthdd0+som*cthdd0) + rd1*(com*&
&   ci*sthdd+som*cthdd) + r*(com*ci*sthddd+som*cthddd) + tddd*(com*ci*&
&   cth-som*sth) + tdd*(com*ci*cthd1-som*sthd1) + tdd0*(com*ci*cthd0-som&
&   *sthd0) + td*(com*ci*cthd0d-som*sthd0d) + td0d*(com*ci*cthd-som*sthd&
&   ) + td0*(com*ci*cthdd0-som*sthdd0) + td1*(com*ci*cthdd-som*sthdd) + &
&   t*(com*ci*cthddd-som*sthddd) - com*si*nddd
  fydd = rdd*(com*ci*sth+som*cth) + rd*(com*ci*sthd0+som*cthd0) + rd0*(&
&   com*ci*sthd+som*cthd) + r*(com*ci*sthdd+som*cthdd) + tdd*(com*ci*cth&
&   -som*sth) + td*(com*ci*cthd0-som*sthd0) + td0*(com*ci*cthd-som*sthd)&
&   + t*(com*ci*cthdd-som*sthdd) - com*si*ndd
  fydd0 = rdd0*(com*ci*sth+som*cth) + rd*(com*ci*sthd1+som*cthd1) + rd1*&
&   (com*ci*sthd+som*cthd) + r*(com*ci*sthdd0+som*cthdd0) + tdd0*(com*ci&
&   *cth-som*sth) + td*(com*ci*cthd1-som*sthd1) + td1*(com*ci*cthd-som*&
&   sthd) + t*(com*ci*cthdd0-som*sthdd0) - com*si*ndd0
  fyd = rd*(com*ci*sth+som*cth) + r*(com*ci*sthd+som*cthd) + td*(com*ci*&
&   cth-som*sth) + t*(com*ci*cthd-som*sthd) - com*si*nd
  fyd0d = rd0d*(com*ci*sth+som*cth) + rd0*(com*ci*sthd1+som*cthd1) + rd1&
&   *(com*ci*sthd0+som*cthd0) + r*(com*ci*sthd0d+som*cthd0d) + td0d*(com&
&   *ci*cth-som*sth) + td0*(com*ci*cthd1-som*sthd1) + td1*(com*ci*cthd0-&
&   som*sthd0) + t*(com*ci*cthd0d-som*sthd0d) - com*si*nd0d
  fyd0 = rd0*(com*ci*sth+som*cth) + r*(com*ci*sthd0+som*cthd0) + td0*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd0-som*sthd0) - com*si*nd0
  fyd1 = rd1*(com*ci*sth+som*cth) + r*(com*ci*sthd1+som*cthd1) + td1*(&
&   com*ci*cth-som*sth) + t*(com*ci*cthd1-som*sthd1) - com*si*nd1
  fy = r*(com*ci*sth+som*cth) + t*(com*ci*cth-som*sth) + n*(-(com*si))
  fzddd = si*(rddd*sth+rdd*sthd1+rdd0*sthd0+rd*sthd0d+rd0d*sthd+rd0*&
&   sthdd0+rd1*sthdd+r*sthddd) + si*(tddd*cth+tdd*cthd1+tdd0*cthd0+td*&
&   cthd0d+td0d*cthd+td0*cthdd0+td1*cthdd+t*cthddd) + ci*nddd
  fzdd = si*(rdd*sth+rd*sthd0+rd0*sthd+r*sthdd) + si*(tdd*cth+td*cthd0+&
&   td0*cthd+t*cthdd) + ci*ndd
  fzdd0 = si*(rdd0*sth+rd*sthd1+rd1*sthd+r*sthdd0) + si*(tdd0*cth+td*&
&   cthd1+td1*cthd+t*cthdd0) + ci*ndd0
  fzd = si*(rd*sth+r*sthd) + si*(td*cth+t*cthd) + ci*nd
  fzd0d = si*(rd0d*sth+rd0*sthd1+rd1*sthd0+r*sthd0d) + si*(td0d*cth+td0*&
&   cthd1+td1*cthd0+t*cthd0d) + ci*nd0d
  fzd0 = si*(rd0*sth+r*sthd0) + si*(td0*cth+t*cthd0) + ci*nd0
  fzd1 = si*(rd1*sth+r*sthd1) + si*(td1*cth+t*cthd1) + ci*nd1
  fz = r*(si*sth) + t*(si*cth) + n*ci
END SUBROUTINE GVEECI_DC_DI_DI

!  Differentiation of gvelvlh_dc_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f rd0 ndd nd n r t fdd td0
!                rd rdd nd0 fd fd0 tdd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f nd n r t rd fd td
!   with respect to varying inputs: m
!  Differentiation of gvelvlh in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f n r t
!   with respect to varying inputs: m
! ######################################################################
! ## GVE in LVLH frame
SUBROUTINE GVELVLH_DC_DI_DI(m, md1, md0, md, i, mu, r, rd1, rd0, rd0d, &
& rd, rdd0, rdd, rddd, t, td1, td0, td0d, td, tdd0, tdd, tddd, n, nd1, &
& nd0, nd0d, nd, ndd0, ndd, nddd, f, fd1, fd0, fd0d, fd, fdd0, fdd, fddd&
&)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: m, i(5), mu
  DOUBLE PRECISION, INTENT(IN) :: md1
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: r(6), t(6), n(6), f
  DOUBLE PRECISION, INTENT(OUT) :: rd1(6), td1(6), nd1(6), fd1
  DOUBLE PRECISION, INTENT(OUT) :: rd0(6), td0(6), nd0(6), fd0
  DOUBLE PRECISION, INTENT(OUT) :: rd0d(6), td0d(6), nd0d(6), fd0d
  DOUBLE PRECISION, INTENT(OUT) :: rd(6), td(6), nd(6), fd
  DOUBLE PRECISION, INTENT(OUT) :: rdd0(6), tdd0(6), ndd0(6), fdd0
  DOUBLE PRECISION, INTENT(OUT) :: rdd(6), tdd(6), ndd(6), fdd
  DOUBLE PRECISION, INTENT(OUT) :: rddd(6), tddd(6), nddd(6), fddd
! Local variables
  DOUBLE PRECISION :: inc, w, a, e, cf, sf, p, rad, b, nnorb, h, theta
  DOUBLE PRECISION :: cfd1, sfd1, radd1, thetad1
  DOUBLE PRECISION :: cfd0, sfd0, radd0, thetad0
  DOUBLE PRECISION :: cfd0d, sfd0d, radd0d, thetad0d
  DOUBLE PRECISION :: cfd, sfd, radd, thetad
  DOUBLE PRECISION :: cfdd0, sfdd0, raddd0, thetadd0
  DOUBLE PRECISION :: cfdd, sfdd, raddd, thetadd
  DOUBLE PRECISION :: cfddd, sfddd, radddd, thetaddd
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
! Orbital elements
! Omega  = I(1)
  inc = i(2)
  w = i(3)
  a = i(4)
  e = i(5)
! Solving Kepler's equation
  CALL KEPLER_DC_DI_DI(e, m, md1, md0, md, f, fd1, fd0, fd0d, fd, fdd0, &
&                fdd, fddd)
! Useful variables
  cfddd = -(fddd*SIN(f)+fdd*fd1*COS(f)+(fdd0*fd0+fd*fd0d)*COS(f)-fd*fd0*&
&   fd1*SIN(f))
  cfdd = -(fdd*SIN(f)+fd*fd0*COS(f))
  cfdd0 = -(fdd0*SIN(f)+fd*fd1*COS(f))
  cfd = -(fd*SIN(f))
  cfd0d = -(fd0d*SIN(f)+fd0*fd1*COS(f))
  cfd0 = -(fd0*SIN(f))
  cfd1 = -(fd1*SIN(f))
  cf = COS(f)
  sfddd = fddd*COS(f) - fdd*fd1*SIN(f) - (fdd0*fd0+fd*fd0d)*SIN(f) - fd*&
&   fd0*fd1*COS(f)
  sfdd = fdd*COS(f) - fd*fd0*SIN(f)
  sfdd0 = fdd0*COS(f) - fd*fd1*SIN(f)
  sfd = fd*COS(f)
  sfd0d = fd0d*COS(f) - fd0*fd1*SIN(f)
  sfd0 = fd0*COS(f)
  sfd1 = fd1*COS(f)
  sf = SIN(f)
  p = a*(1.0d0-e**2)
  radddd = -(((p*e*(cfddd*(1.0d0+e*cf)**2+cfdd*2*(1.0d0+e*cf)*e*cfd1)-p*&
&   e**2*2*((cfdd0*cfd0+cfd*cfd0d)*(1.0d0+e*cf)+cfd*cfd0*e*cfd1))*(1.0d0&
&   +e*cf)**4-(p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)*&
&   2**2*(1.0d0+e*cf)**3*e*cfd1)/(((1.0d0+e*cf)**2)**2)**2)
  raddd = -((p*e*cfdd*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd0)/((&
&   1.0d0+e*cf)**2)**2)
  raddd0 = -((p*e*cfdd0*(1.0d0+e*cf)**2-p*e**2*cfd*2*(1.0d0+e*cf)*cfd1)/&
&   ((1.0d0+e*cf)**2)**2)
  radd = -(p*e*cfd/(1.0d0+e*cf)**2)
  radd0d = -((p*e*cfd0d*(1.0d0+e*cf)**2-p*e**2*cfd0*2*(1.0d0+e*cf)*cfd1)&
&   /((1.0d0+e*cf)**2)**2)
  radd0 = -(p*e*cfd0/(1.0d0+e*cf)**2)
  radd1 = -(p*e*cfd1/(1.0d0+e*cf)**2)
  rad = p/(1.0d0+e*cf)
  arg1 = 1.0d0 - e**2
  result1 = SQRT(arg1)
  b = a*result1
  arg1 = mu/a**3
  nnorb = SQRT(arg1)
  h = nnorb*a*b
  thetaddd = fddd
  thetadd = fdd
  thetadd0 = fdd0
  thetad = fd
  thetad0d = fd0d
  thetad0 = fd0
  thetad1 = fd1
  theta = w + f
! GVEs
  rd(1) = 0.d0
  rd0(1) = 0.d0
  rd1(1) = 0.D0
  r(1) = 0.0d0
  td(1) = 0.d0
  td0(1) = 0.d0
  td1(1) = 0.D0
  t(1) = 0.0d0
  nd = 0.d0
  ndd = 0.d0
  nddd = 0.D0
  nddd(1) = (radddd*SIN(theta)+raddd*thetad1*COS(theta)+(raddd0*thetad0+&
&   radd*thetad0d)*COS(theta)-radd*thetad0*thetad1*SIN(theta)+(radd0d*&
&   thetad+radd0*thetadd0+radd1*thetadd+rad*thetaddd)*COS(theta)-(radd0*&
&   thetad+rad*thetadd)*thetad1*SIN(theta)-((radd1*thetad+rad*thetadd0)*&
&   thetad0+rad*thetad*thetad0d)*SIN(theta)-rad*thetad*thetad0*thetad1*&
&   COS(theta))/h/SIN(inc)
  ndd(1) = (raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*thetad+rad*&
&   thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(inc)
  ndd0 = 0.D0
  ndd0(1) = (raddd0*SIN(theta)+radd*thetad1*COS(theta)+(radd1*thetad+rad&
&   *thetadd0)*COS(theta)-rad*thetad*thetad1*SIN(theta))/h/SIN(inc)
  nd(1) = (radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc)
  nd0 = 0.d0
  nd0d = 0.D0
  nd0d(1) = (radd0d*SIN(theta)+radd0*thetad1*COS(theta)+(radd1*thetad0+&
&   rad*thetad0d)*COS(theta)-rad*thetad0*thetad1*SIN(theta))/h/SIN(inc)
  nd0(1) = (radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(inc)
  nd1 = 0.D0
  nd1(1) = (radd1*SIN(theta)+rad*thetad1*COS(theta))/h/SIN(inc)
  n(1) = rad*SIN(theta)/h/SIN(inc)
  rd(2) = 0.d0
  rd0(2) = 0.d0
  rd1(2) = 0.D0
  r(2) = 0.0d0
  td(2) = 0.d0
  td0(2) = 0.d0
  td1(2) = 0.D0
  t(2) = 0.0d0
  nddd(2) = (radddd*COS(theta)-raddd*thetad1*SIN(theta)-(raddd0*thetad0+&
&   radd*thetad0d)*SIN(theta)-radd*thetad0*thetad1*COS(theta)-(radd0d*&
&   thetad+radd0*thetadd0+radd1*thetadd+rad*thetaddd)*SIN(theta)-(radd0*&
&   thetad+rad*thetadd)*thetad1*COS(theta)-((radd1*thetad+rad*thetadd0)*&
&   thetad0+rad*thetad*thetad0d)*COS(theta)+rad*thetad*thetad0*thetad1*&
&   SIN(theta))/h
  ndd(2) = (raddd*COS(theta)-radd*thetad0*SIN(theta)-(radd0*thetad+rad*&
&   thetadd)*SIN(theta)-rad*thetad*thetad0*COS(theta))/h
  ndd0(2) = (raddd0*COS(theta)-radd*thetad1*SIN(theta)-(radd1*thetad+rad&
&   *thetadd0)*SIN(theta)-rad*thetad*thetad1*COS(theta))/h
  nd(2) = (radd*COS(theta)-rad*thetad*SIN(theta))/h
  nd0d(2) = (radd0d*COS(theta)-radd0*thetad1*SIN(theta)-(radd1*thetad0+&
&   rad*thetad0d)*SIN(theta)-rad*thetad0*thetad1*COS(theta))/h
  nd0(2) = (radd0*COS(theta)-rad*thetad0*SIN(theta))/h
  nd1(2) = (radd1*COS(theta)-rad*thetad1*SIN(theta))/h
  n(2) = rad*COS(theta)/h
  rd = 0.d0
  rdd = 0.d0
  rddd = 0.D0
  rddd(3) = -(p*cfddd/h/e)
  rdd(3) = -(p*cfdd/h/e)
  rdd0 = 0.D0
  rdd0(3) = -(p*cfdd0/h/e)
  rd(3) = -(p*cfd/h/e)
  rd0 = 0.d0
  rd0d = 0.D0
  rd0d(3) = -(p*cfd0d/h/e)
  rd0(3) = -(p*cfd0/h/e)
  rd1 = 0.D0
  rd1(3) = -(p*cfd1/h/e)
  r(3) = -(p*cf/h/e)
  td = 0.d0
  tdd = 0.d0
  tddd = 0.D0
  tddd(3) = (radddd*sf+raddd*sfd1+raddd0*sfd0+radd*sfd0d+radd0d*sfd+&
&   radd0*sfdd0+radd1*sfdd+(p+rad)*sfddd)/h/e
  tdd(3) = (raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/h/e
  tdd0 = 0.D0
  tdd0(3) = (raddd0*sf+radd*sfd1+radd1*sfd+(p+rad)*sfdd0)/h/e
  td(3) = (radd*sf+(p+rad)*sfd)/h/e
  td0 = 0.d0
  td0d = 0.D0
  td0d(3) = (radd0d*sf+radd0*sfd1+radd1*sfd0+(p+rad)*sfd0d)/h/e
  td0(3) = (radd0*sf+(p+rad)*sfd0)/h/e
  td1 = 0.D0
  td1(3) = (radd1*sf+(p+rad)*sfd1)/h/e
  t(3) = (p+rad)*sf/h/e
  nddd(3) = -(COS(inc)*(radddd*SIN(theta)+raddd*thetad1*COS(theta)+(&
&   raddd0*thetad0+radd*thetad0d)*COS(theta)-radd*thetad0*thetad1*SIN(&
&   theta)+(radd0d*thetad+radd0*thetadd0+radd1*thetadd+rad*thetaddd)*COS&
&   (theta)-(radd0*thetad+rad*thetadd)*thetad1*SIN(theta)-((radd1*thetad&
&   +rad*thetadd0)*thetad0+rad*thetad*thetad0d)*SIN(theta)-rad*thetad*&
&   thetad0*thetad1*COS(theta))/h/SIN(inc))
  ndd(3) = -(COS(inc)*(raddd*SIN(theta)+radd*thetad0*COS(theta)+(radd0*&
&   thetad+rad*thetadd)*COS(theta)-rad*thetad*thetad0*SIN(theta))/h/SIN(&
&   inc))
  ndd0(3) = -(COS(inc)*(raddd0*SIN(theta)+radd*thetad1*COS(theta)+(radd1&
&   *thetad+rad*thetadd0)*COS(theta)-rad*thetad*thetad1*SIN(theta))/h/&
&   SIN(inc))
  nd(3) = -(COS(inc)*(radd*SIN(theta)+rad*thetad*COS(theta))/h/SIN(inc))
  nd0d(3) = -(COS(inc)*(radd0d*SIN(theta)+radd0*thetad1*COS(theta)+(&
&   radd1*thetad0+rad*thetad0d)*COS(theta)-rad*thetad0*thetad1*SIN(theta&
&   ))/h/SIN(inc))
  nd0(3) = -(COS(inc)*(radd0*SIN(theta)+rad*thetad0*COS(theta))/h/SIN(&
&   inc))
  nd1(3) = -(COS(inc)*(radd1*SIN(theta)+rad*thetad1*COS(theta))/h/SIN(&
&   inc))
  n(3) = -(rad*SIN(theta)*COS(inc)/h/SIN(inc))
  rddd(4) = 2.0d0*a**2*e*sfddd/h
  rdd(4) = 2.0d0*a**2*e*sfdd/h
  rdd0(4) = 2.0d0*a**2*e*sfdd0/h
  rd(4) = 2.0d0*a**2*e*sfd/h
  rd0d(4) = 2.0d0*a**2*e*sfd0d/h
  rd0(4) = 2.0d0*a**2*e*sfd0/h
  rd1(4) = 2.0d0*a**2*e*sfd1/h
  r(4) = 2.0d0*a**2*e*sf/h
  tddd(4) = -(((2.0d0*a**2*p*(radddd*rad**2+raddd*2*rad*radd1)/h-2.0d0*a&
&   **2*p*2*((raddd0*rad+radd*radd1)*radd0+radd*rad*radd0d)/h)*rad**4-(&
&   2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/h)*2**2*&
&   rad**3*radd1)/((rad**2)**2)**2)
  tdd(4) = -((2.0d0*a**2*p*raddd*rad**2/h-2.0d0*a**2*p*radd*2*rad*radd0/&
&   h)/(rad**2)**2)
  tdd0(4) = -((2.0d0*a**2*p*raddd0*rad**2/h-2.0d0*a**2*p*radd*2*rad*&
&   radd1/h)/(rad**2)**2)
  td(4) = -(2.0d0*a**2*p*radd/h/rad**2)
  td0d(4) = -((2.0d0*a**2*p*radd0d*rad**2/h-2.0d0*a**2*p*radd0*2*rad*&
&   radd1/h)/(rad**2)**2)
  td0(4) = -(2.0d0*a**2*p*radd0/h/rad**2)
  td1(4) = -(2.0d0*a**2*p*radd1/h/rad**2)
  t(4) = 2.0d0*a**2*p/h/rad
  nddd(4) = 0.D0
  ndd(4) = 0.d0
  ndd0(4) = 0.D0
  nd(4) = 0.d0
  nd0d(4) = 0.D0
  nd0(4) = 0.d0
  nd1(4) = 0.D0
  n(4) = 0.0d0
  rddd(5) = p*sfddd/h
  rdd(5) = p*sfdd/h
  rdd0(5) = p*sfdd0/h
  rd(5) = p*sfd/h
  rd0d(5) = p*sfd0d/h
  rd0(5) = p*sfd0/h
  rd1(5) = p*sfd1/h
  r(5) = p*sf/h
  tddd(5) = (radddd*cf+raddd*cfd1+raddd0*cfd0+radd*cfd0d+radd0d*cfd+&
&   radd0*cfdd0+radd1*cfdd+(p+rad)*cfddd+e*radddd)/h
  tdd(5) = (raddd*cf+radd*cfd0+radd0*cfd+(p+rad)*cfdd+e*raddd)/h
  tdd0(5) = (raddd0*cf+radd*cfd1+radd1*cfd+(p+rad)*cfdd0+e*raddd0)/h
  td(5) = (radd*cf+(p+rad)*cfd+e*radd)/h
  td0d(5) = (radd0d*cf+radd0*cfd1+radd1*cfd0+(p+rad)*cfd0d+e*radd0d)/h
  td0(5) = (radd0*cf+(p+rad)*cfd0+e*radd0)/h
  td1(5) = (radd1*cf+(p+rad)*cfd1+e*radd1)/h
  t(5) = ((p+rad)*cf+rad*e)/h
  nddd(5) = 0.D0
  ndd(5) = 0.d0
  ndd0(5) = 0.D0
  nd(5) = 0.d0
  nd0d(5) = 0.D0
  nd0(5) = 0.d0
  nd1(5) = 0.D0
  n(5) = 0.0d0
  rddd(6) = p*cfddd - 2.0d0*e*b*radddd/a/h/e
  rdd(6) = p*cfdd - 2.0d0*e*b*raddd/a/h/e
  rdd0(6) = p*cfdd0 - 2.0d0*e*b*raddd0/a/h/e
  rd(6) = p*cfd - 2.0d0*e*b*radd/a/h/e
  rd0d(6) = p*cfd0d - 2.0d0*e*b*radd0d/a/h/e
  rd0(6) = p*cfd0 - 2.0d0*e*b*radd0/a/h/e
  rd1(6) = p*cfd1 - 2.0d0*e*b*radd1/a/h/e
  r(6) = p*cf - 2.0d0*rad*e*b/a/h/e
  tddd(6) = -(b*(radddd*sf+raddd*sfd1+raddd0*sfd0+radd*sfd0d+radd0d*sfd+&
&   radd0*sfdd0+radd1*sfdd+(p+rad)*sfddd)/a/h/e)
  tdd(6) = -(b*(raddd*sf+radd*sfd0+radd0*sfd+(p+rad)*sfdd)/a/h/e)
  tdd0(6) = -(b*(raddd0*sf+radd*sfd1+radd1*sfd+(p+rad)*sfdd0)/a/h/e)
  td(6) = -(b*(radd*sf+(p+rad)*sfd)/a/h/e)
  td0d(6) = -(b*(radd0d*sf+radd0*sfd1+radd1*sfd0+(p+rad)*sfd0d)/a/h/e)
  td0(6) = -(b*(radd0*sf+(p+rad)*sfd0)/a/h/e)
  td1(6) = -(b*(radd1*sf+(p+rad)*sfd1)/a/h/e)
  t(6) = -((p+rad)*sf*b/a/h/e)
  nddd(6) = 0.D0
  ndd(6) = 0.d0
  ndd0(6) = 0.D0
  nd(6) = 0.d0
  nd0d(6) = 0.D0
  nd0(6) = 0.d0
  nd1(6) = 0.D0
  n(6) = 0.0d0
END SUBROUTINE GVELVLH_DC_DI_DI

!  Differentiation of kepler_dc_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fdd fd fd0
!   with respect to varying inputs: m
!  Differentiation of kepler_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f fd
!   with respect to varying inputs: m
!  Differentiation of kepler in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: f
!   with respect to varying inputs: m
! ######################################################################
! ## Kepler's equation
SUBROUTINE KEPLER_DC_DI_DI(ecc, m, md1, md0, md, f, fd1, fd0, fd0d, fd, &
& fdd0, fdd, fddd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: ecc, m
  DOUBLE PRECISION, INTENT(IN) :: md1
  DOUBLE PRECISION, INTENT(IN) :: md0
  DOUBLE PRECISION, INTENT(IN) :: md
  DOUBLE PRECISION, INTENT(OUT) :: f
  DOUBLE PRECISION, INTENT(OUT) :: fd1
  DOUBLE PRECISION, INTENT(OUT) :: fd0
  DOUBLE PRECISION, INTENT(OUT) :: fd0d
  DOUBLE PRECISION, INTENT(OUT) :: fd
  DOUBLE PRECISION, INTENT(OUT) :: fdd0
  DOUBLE PRECISION, INTENT(OUT) :: fdd
  DOUBLE PRECISION, INTENT(OUT) :: fddd
! Local variables
  INTEGER :: nmax, ii
  DOUBLE PRECISION :: e, k, dk
  DOUBLE PRECISION :: ed1, kd1, dkd1
  DOUBLE PRECISION :: ed0, kd0, dkd0
  DOUBLE PRECISION :: ed0d, kd0d, dkd0d
  DOUBLE PRECISION :: ed, kd, dkd
  DOUBLE PRECISION :: edd0, kdd0, dkdd0
  DOUBLE PRECISION :: edd, kdd, dkdd
  DOUBLE PRECISION :: eddd, kddd, dkddd
  INTRINSIC SIN
  INTRINSIC COS
  INTRINSIC SQRT
  INTRINSIC ATAN2
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d0d
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd0
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: arg1ddd
  DOUBLE PRECISION :: result2
  DOUBLE PRECISION :: arg2
  DOUBLE PRECISION :: arg2d1
  DOUBLE PRECISION :: arg2d0
  DOUBLE PRECISION :: arg2d0d
  DOUBLE PRECISION :: arg2d
  DOUBLE PRECISION :: arg2dd0
  DOUBLE PRECISION :: arg2dd
  DOUBLE PRECISION :: arg2ddd
! Set parameters
  nmax = 20
! Newton-Rapshon
  ed = md
  ed0 = md0
  ed1 = md1
  e = m
  edd = 0.d0
  ed0d = 0.D0
  edd0 = 0.D0
  eddd = 0.D0
  DO ii=1,nmax
    kddd = eddd - ecc*(eddd*COS(e)-edd*ed1*SIN(e)-(edd0*ed0+ed*ed0d)*SIN&
&     (e)-ed*ed0*ed1*COS(e))
    kdd = edd - ecc*(edd*COS(e)-ed*ed0*SIN(e))
    kdd0 = edd0 - ecc*(edd0*COS(e)-ed*ed1*SIN(e))
    kd = ed - ecc*ed*COS(e) - md
    kd0d = ed0d - ecc*(ed0d*COS(e)-ed0*ed1*SIN(e))
    kd0 = ed0 - ecc*ed0*COS(e) - md0
    kd1 = ed1 - ecc*ed1*COS(e) - md1
    k = e - ecc*SIN(e) - m
    dkddd = ecc*(eddd*SIN(e)+edd*ed1*COS(e)+(edd0*ed0+ed*ed0d)*COS(e)-ed&
&     *ed0*ed1*SIN(e))
    dkdd = ecc*(edd*SIN(e)+ed*ed0*COS(e))
    dkdd0 = ecc*(edd0*SIN(e)+ed*ed1*COS(e))
    dkd = ecc*ed*SIN(e)
    dkd0d = ecc*(ed0d*SIN(e)+ed0*ed1*COS(e))
    dkd0 = ecc*ed0*SIN(e)
    dkd1 = ecc*ed1*SIN(e)
    dk = 1.0d0 - ecc*COS(e)
    eddd = eddd - (((kddd*dk+kdd*dkd1+kdd0*dkd0+kd*dkd0d-kd0d*dkd-kd0*&
&     dkdd0-kd1*dkdd-k*dkddd)*dk**2+(kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*2*dk&
&     *dkd1-2*((kdd0*dk+kd*dkd1-kd1*dkd-k*dkdd0)*dk*dkd0)-2*((kd*dk-k*&
&     dkd)*(dkd1*dkd0+dk*dkd0d)))*dk**4-((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)&
&     *dk**2-(kd*dk-k*dkd)*2*dk*dkd0)*2**2*dk**3*dkd1)/((dk**2)**2)**2
    edd = edd - ((kdd*dk+kd*dkd0-kd0*dkd-k*dkdd)*dk**2-(kd*dk-k*dkd)*2*&
&     dk*dkd0)/(dk**2)**2
    edd0 = edd0 - ((kdd0*dk+kd*dkd1-kd1*dkd-k*dkdd0)*dk**2-(kd*dk-k*dkd)&
&     *2*dk*dkd1)/(dk**2)**2
    ed = ed - (kd*dk-k*dkd)/dk**2
    ed0d = ed0d - ((kd0d*dk+kd0*dkd1-kd1*dkd0-k*dkd0d)*dk**2-(kd0*dk-k*&
&     dkd0)*2*dk*dkd1)/(dk**2)**2
    ed0 = ed0 - (kd0*dk-k*dkd0)/dk**2
    ed1 = ed1 - (kd1*dk-k*dkd1)/dk**2
    e = e - k/dk
  END DO
! True Anomaly
  result1 = SQRT(1.0d0 + ecc)
  arg1ddd = result1*(eddd*COS(e/2.0d0)-edd*ed1*SIN(e/2.0d0)/2.0d0-((edd0&
&   *ed0+ed*ed0d)*SIN(e/2.0d0)+ed*ed0*ed1*COS(e/2.0d0)/2.0d0)/2.0d0)/&
&   2.0d0
  arg1dd = result1*(edd*COS(e/2.0d0)-ed*ed0*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1dd0 = result1*(edd0*COS(e/2.0d0)-ed*ed1*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d = result1*ed*COS(e/2.0d0)/2.0d0
  arg1d0d = result1*(ed0d*COS(e/2.0d0)-ed0*ed1*SIN(e/2.0d0)/2.0d0)/2.0d0
  arg1d0 = result1*ed0*COS(e/2.0d0)/2.0d0
  arg1d1 = result1*ed1*COS(e/2.0d0)/2.0d0
  arg1 = result1*SIN(e/2.0d0)
  result2 = SQRT(1.0d0 - ecc)
  arg2ddd = -(result2*(eddd*SIN(e/2.0d0)+edd*ed1*COS(e/2.0d0)/2.0d0+((&
&   edd0*ed0+ed*ed0d)*COS(e/2.0d0)-ed*ed0*ed1*SIN(e/2.0d0)/2.0d0)/2.0d0)&
&   /2.0d0)
  arg2dd = -(result2*(edd*SIN(e/2.0d0)+ed*ed0*COS(e/2.0d0)/2.0d0)/2.0d0)
  arg2dd0 = -(result2*(edd0*SIN(e/2.0d0)+ed*ed1*COS(e/2.0d0)/2.0d0)/&
&   2.0d0)
  arg2d = -(result2*ed*SIN(e/2.0d0)/2.0d0)
  arg2d0d = -(result2*(ed0d*SIN(e/2.0d0)+ed0*ed1*COS(e/2.0d0)/2.0d0)/&
&   2.0d0)
  arg2d0 = -(result2*ed0*SIN(e/2.0d0)/2.0d0)
  arg2d1 = -(result2*ed1*SIN(e/2.0d0)/2.0d0)
  arg2 = result2*COS(e/2.0d0)
  fddd = ((2.0d0*((arg1ddd*arg2+arg1dd*arg2d1+arg1dd0*arg2d0+arg1d*&
&   arg2d0d-arg2ddd*arg1-arg2dd*arg1d1-arg2dd0*arg1d0-arg2d*arg1d0d)*(&
&   arg1**2+arg2**2)+(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)&
&   *(2*arg1*arg1d1+2*arg2*arg2d1))-2.0d0*((arg1dd0*arg2+arg1d*arg2d1-&
&   arg2dd0*arg1-arg2d*arg1d1)*(2*arg1*arg1d0+2*arg2*arg2d0)+(arg1d*arg2&
&   -arg2d*arg1)*(2*(arg1d1*arg1d0)+2*(arg1*arg1d0d)+2*(arg2d1*arg2d0)+2&
&   *(arg2*arg2d0d))))*(arg1**2+arg2**2)**2-(2.0d0*(arg1dd*arg2+arg1d*&
&   arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1**2+arg2**2)-2.0d0*(arg1d*arg2&
&   -arg2d*arg1)*(2*arg1*arg1d0+2*arg2*arg2d0))*2*(arg1**2+arg2**2)*(2*&
&   arg1*arg1d1+2*arg2*arg2d1))/((arg1**2+arg2**2)**2)**2
  fdd = (2.0d0*(arg1dd*arg2+arg1d*arg2d0-arg2dd*arg1-arg2d*arg1d0)*(arg1&
&   **2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d0+2*arg2*&
&   arg2d0))/(arg1**2+arg2**2)**2
  fdd0 = (2.0d0*(arg1dd0*arg2+arg1d*arg2d1-arg2dd0*arg1-arg2d*arg1d1)*(&
&   arg1**2+arg2**2)-2.0d0*(arg1d*arg2-arg2d*arg1)*(2*arg1*arg1d1+2*arg2&
&   *arg2d1))/(arg1**2+arg2**2)**2
  fd = 2.0d0*(arg1d*arg2-arg2d*arg1)/(arg1**2+arg2**2)
  fd0d = (2.0d0*(arg1d0d*arg2+arg1d0*arg2d1-arg2d0d*arg1-arg2d0*arg1d1)*&
&   (arg1**2+arg2**2)-2.0d0*(arg1d0*arg2-arg2d0*arg1)*(2*arg1*arg1d1+2*&
&   arg2*arg2d1))/(arg1**2+arg2**2)**2
  fd0 = 2.0d0*(arg1d0*arg2-arg2d0*arg1)/(arg1**2+arg2**2)
  fd1 = 2.0d0*(arg1d1*arg2-arg2d1*arg1)/(arg1**2+arg2**2)
  f = 2.0d0*ATAN2(arg1, arg2)
END SUBROUTINE KEPLER_DC_DI_DI

!  Differentiation of dot_dc_di in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resdd resd res resd0
!   with respect to varying inputs: u v ud udd vd0 vd ud0 vdd
!  Differentiation of dot_dc in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: resd res
!   with respect to varying inputs: u v ud vd
!  Differentiation of dot in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: res
!   with respect to varying inputs: u v
! ######################################################################
! ## Dot product
SUBROUTINE DOT_DC_DI_DI(n, u, ud1, ud0, ud0d, ud, udd0, udd, uddd, v, &
& vd1, vd0, vd0d, vd, vdd0, vdd, vddd, res, resd1, resd0, resd0d, resd, &
& resdd0, resdd, resddd)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, INTENT(IN) :: u(n), v(n)
  DOUBLE PRECISION, INTENT(IN) :: ud1(n), vd1(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0(n), vd0(n)
  DOUBLE PRECISION, INTENT(IN) :: ud0d(n), vd0d(n)
  DOUBLE PRECISION, INTENT(IN) :: ud(n), vd(n)
  DOUBLE PRECISION, INTENT(IN) :: udd0(n), vdd0(n)
  DOUBLE PRECISION, INTENT(IN) :: udd(n), vdd(n)
  DOUBLE PRECISION, INTENT(IN) :: uddd(n), vddd(n)
  DOUBLE PRECISION, INTENT(OUT) :: res
  DOUBLE PRECISION, INTENT(OUT) :: resd1
  DOUBLE PRECISION, INTENT(OUT) :: resd0
  DOUBLE PRECISION, INTENT(OUT) :: resd0d
  DOUBLE PRECISION, INTENT(OUT) :: resd
  DOUBLE PRECISION, INTENT(OUT) :: resdd0
  DOUBLE PRECISION, INTENT(OUT) :: resdd
  DOUBLE PRECISION, INTENT(OUT) :: resddd
! local variables
  INTEGER :: i
  res = 0.0d0
  resd = 0.d0
  resdd = 0.d0
  resd0 = 0.d0
  resddd = 0.D0
  resdd0 = 0.D0
  resd1 = 0.D0
  resd0d = 0.D0
  DO i=1,n
    resddd = resddd + uddd(i)*v(i) + udd(i)*vd1(i) + udd0(i)*vd0(i) + ud&
&     (i)*vd0d(i) + ud0d(i)*vd(i) + ud0(i)*vdd0(i) + ud1(i)*vdd(i) + u(i&
&     )*vddd(i)
    resdd = resdd + udd(i)*v(i) + ud(i)*vd0(i) + ud0(i)*vd(i) + u(i)*vdd&
&     (i)
    resdd0 = resdd0 + udd0(i)*v(i) + ud(i)*vd1(i) + ud1(i)*vd(i) + u(i)*&
&     vdd0(i)
    resd = resd + ud(i)*v(i) + u(i)*vd(i)
    resd0d = resd0d + ud0d(i)*v(i) + ud0(i)*vd1(i) + ud1(i)*vd0(i) + u(i&
&     )*vd0d(i)
    resd0 = resd0 + ud0(i)*v(i) + u(i)*vd0(i)
    resd1 = resd1 + ud1(i)*v(i) + u(i)*vd1(i)
    res = res + u(i)*v(i)
  END DO
END SUBROUTINE DOT_DC_DI_DI

